# 2019.9.26

Sep 26 Thu

## SE-227::CSE

今天的话题是：Fault Tolerant & Crash Consistency. 

(你能忍受崩溃吗？崩溃后的你和之前的你，还一致吗？)

### 崩溃时发生啥事？

考虑一下我们的调用层次。

iNode -> Bitmap -> DataBlock

从调用顺序上来讲，从上到下可能在任意一层发生的时候发生 Crash。

但是，对于 FileSystem 来讲，能否确定在七层里的任何一层停下来（Crash），都不会造成灾难性的后果（会不会有 Inconsistency？）

### 顺序，顺序

为了 Performance（性能表现），我们可能会轻改一些指令的运行顺序，比如近先远后。这样的 Trick 会不会影响我们的 Consistency 呢？

事实上，一旦涉及到「顺序」，就能考虑到可能的情况数目会非常爆炸。类似于 Thread 和 Process 并行造成的多线程 Bug，很难调试或是找出其中所有情况。

为了保证某些顺序，我们会使用 `assert` 断言机制：不管你怎么进行各种顺序，我们总有一些断言：

```jinkeyulv
没有一个 Block 同时被两个文件所引用。
```

在出现这种 `assert(false)` 的时候，我们就确认事情不对劲了。

### 大停电！

我们考虑的故障为：磁盘没坏（good），但是断电当时所进行的操作只完成了一半。有可能是创建了 inode 但是 Blocks 还没写进去；或者是 Block 写进去了但是 Bitmap 却没有更新。

### 衡量 Failure Rate

* MTTF

* MTTR

* MTBF
1. MTBF——全称是Mean Time Between Failure，即平均无故障工作时间。就是从新的产品在规定的工作环境条件下开始工作到出现第一个故障的时间的平均值。MTBF越长表示可靠性越高正确工作能力越强 。

2. MTTR——全称是Mean Time To Repair，即平均修复时间。是指可修复产品的平均修复时间，就是从出现故障到修复中间的这段时间。MTTR越短表示易恢复性越好。

3. MTTF——全称是Mean Time To Failure，即平均失效时间。系统平均能够正常运行多长时间，才发生一次故障。系统的可靠性越高，平均无故障时间越长。

### Voting Strategy

硬件内民主机制

多个独立部件进行决策，最后看谁多谁胜利。

但是这就有个问题：必然有个部件来最后决定 Voting 结果。

但是万一计票员也故障了呢？问题大了

因此我们最好不要安排这个计票员，把这个任务交给 Client 来处理。

这种 Voting Strategy 会怎么影响我们的 Failure Rate 呢？

假设一个部件独立进行运行决策，平均无故障运行时间为 2000 小时。

那么如果我们有三个独立部件独立决策，那么就可以把 MTBF 延长到 2000 × (3 - 1) = 4000 小时。

只有两个人都故障的时候才会爆炸。

> 老拿飞机举例子…
> 
> 很多飞机都可以单发运行。但是这样总归是不安全…
> 
> 毕竟，飞机的引擎之间的损坏并非是完全独立的。

### Magnetic Disk

那么在磁盘中我们能做到那些策略呢？

#### ALL OR NOTHING

* (ALMOST_)ALL_OR_NOTHING_PUT

* ALL_OR_NOTHING_GET

要么全读出来／写进去，要么啥也没有。

GET 是可以是完全实现的，PUT 只是 ALMOST。

观察我们的七层磁盘模型，我们考虑到在执行到其中任何一部分的时刻都可能发生中断。那么在这所有的情况下都可以保证上面两条都满足吗？

### ALL/NOTHING 策略

在每一层的时候，都保留三个标识位：

|            | L 1 | L 2 | L 3 | L 4 | L 5 | L 6 | L 7 |
| ---------- | --- | --- | --- | --- | --- | --- | --- |
| bit 1=>    |     |     |     |     |     |     |     |
| bit 2<=    |     |     |     |     |     |     |     |
| bit 3(old) |     |     |     |     |     |     |     |

数据会从 ======>======>======>======>======>======>======>======>======>

这边过去，然后再从底层

<======<======<======<======<======<======<======<======<======<======

报告回来。

如果 => 位 跟 <= 位是一致的，那么就说明（在这一层）写操作成功完成了的。

所以就返回其中任何一个就行。

如果不一致，说明没有成功写入，返回 old bit。

### RAID

R = Redundant：冗余磁盘阵列

举例：RAID 1及以上的 RAID 是可以容错的；同样的数据向两个盘中同时存储。

而 RAID 0 是没有容错的；而且比起普通的盘来说更糟糕：两块盘里坏一块就全完蛋。

#### Decay（腐烂）

磁盘的数据在时间的作用下、外力的物理作用下可能会导致数据跳变（随机丢失一些数位）。

#### RAID 4

四个 RAID：三个盘里面存不一样的数据，最后的一个盘（Parity Disk）存前面三个盘的奇偶校验。

任何一块盘坏掉，其他三块盘都可以确定出它的 Bit 位置（利用 XoR）。

但这样的话：Parity Disk 校验盘就势必承受三倍于其他盘的读写。更容易损坏。

按照这种做法，RAID N + 1 提供 N 块盘的存储，但是其中那块校验盘更容易坏。

#### fscheck

每启动 k 次（k < 100），Linux 就会 trigger 一次 fscheck，在后台启动您的磁盘 META-INF。他会干些啥呢？

##### .LOST_AND_FOUND

找到了一个被遗弃的 inode，但是哪个目录下都找不到他；那就把它放到失物招领文件夹里，你要的话去拿出来；不要的话就删了吧（

##### Flying Pointer

有个 Block 指针指向了一个完全不存在的 Block 上。fscheck 就会检查并处理这事。

## SE-344::CG2019

### Review of Assignment #1

$$\alpha + \beta = \gamma$$

### CG 发展 + 应用

#### 發展

1946, ENIAC, 其创始人做了个梦…当时的 ENIAC 吃的是打孔纸带（输出也是），完全没有图形输出。

1950, MIT, Whirl Wind I 实现了第一台带显示器的计算机。用的是类似示波器的 CRT，只能显示非常简单的图形。

1958, Calcomp, 滚筒绘图仪。

1958, GerBer, 平板式绘图仪。

1960s, MIT, Lincoln Lab, 可交互的 CRT 显示器

> 插一句：此时电视技术已经非常成熟了，因此也影响了计算机图形的发展历程。迄今为止，计算机图形技术都采用基于光栅的图形显示。

1980s, 出现了使用光栅图形显示器的 PC & Graphics Workstation。

> 请注意：计算机图形所采用的 RGB 色域事实上并不能很好地表示出真实世界中的所有颜色。这个色域是比较窄的。图形工作站意在支持更多色彩的表示方式，实现真正的颜色「WYSIWYG」。

#### 應用

* Films，辅助影视后期制作。
* Games，对于实时性的要求特别高。
* Medical Imaging，医学图像学。

### Graphics 的存储 + 表示 + 显示

表示和显示的区别：表示需要将所有的数据都表示出来，
然而显示的话仅仅显示那些必要的内容，很可能只有表示的数据（或者，实际的数据）的一部分。

例如：被空间遮挡的物体不会被显示；物体的一些信息：如法线等不会显示；

甚至，生成的图像也并非全部用于显示；一般会从生成的管线中进行剪裁（Clipping），这个图形显示的小窗口（Window）会因视点的位置（Viewpoint，视口）变换而变换。

> 注意：此 Window 非彼 `Windows` 之 Window。

#### 存儲

#### 表示

图形是如何表示的？

这很难讲，主要是无法提出一个永远适用的标准来。

不同的应用场景总是会适用不同的表示方法。不同的物体也应该用不同的方式来表示。不能存在一个放四海准的统一标准。

在我们的 OpenGL 表示方法中，常用的表示方法是 顶点 三角形 上色。

三个顶点所构成的三角形都会被上成相同的颜色。在此基础上进行栅格化，确定到每个像素点应该取什么颜色。

#### 顯示

在你知道了每个像素点的颜色之后，就可以交给 Graphics Card 来渲染了。

### 图形处理管线

> 也称渲染管线、渲染流水线, the rendering pipeline。

图形的显示本质上是以流水线来进行的。流水线的特点就是：其中一点的栓塞就会变成整体性能的瓶颈。因为其中每一级的产物都是下一级的必要输入。这样就会导致严重的卡顿和延迟。

管线里面有啥呢？

Geometry Pipeline ==光=栅=化=> Imaging Pipeline

#### Geometry Pipeline

也叫做几何管线、3D 管线。这一段处理的都是 3D 空间内的顶点、边、光影、运动等等东西都是在此段进行考虑的。这一段还没有进行栅格化，操作的量都是矢量、几何量。

* 时间：动画与交互
* 形状：建模
* 着色：反射与光照
* 视图：变换与剪裁
* 消隐：隐藏线／隐藏面的消除

这些东西都是 G.P. 需要考虑的事情。

#### 光栅化

光栅化就是 G.P => I.P. 的过程。这个过程是必然会导致大量信息丢失的。但是为了显示，不得不采用这种光栅化的操作。为了尽量减少损失，这里有非常大量的算法和操作，就是为了保留「真实感」。

> 举例：一个几何管线里的球，如果你不加算法地渲染成二维，那肯定渲染成一个纯色的圆。

#### Imaging Pipeline

此段已经把 Geometry pipeline 里面的几何数学量都采样、投影到 2D 平面，得到了一组像素化的 Pixels。

此时所有的光影、集合、3D 信息全部都丢失了。你得到的仅仅是一些平面像素颜色点。只能操作那些像素点了。

> 为了尽量保留真实感，在 Imaging Pipeline 里面需要做的事情有：

* 光栅化、采样
* 纹理映射
* 图像合成
* 光强、色彩量化
* 帧缓存、显示

> Question: 管线优化：能在哪里进行优化？如何找到哪里是瓶颈？如何优化？

### 表示方法

#### 线框模型

这个只能用来快速看一看，所有的面都不渲染，只渲染线条。问题就是会出现二义性，部分线条之间无法分析出来深度关系。


#### 面模型

只渲染面，而被面遮挡的内部皆不渲染。

#### 体表模型

用非常简单的几何体来代替我们的几何体，如四面体、六面体、球等等。

#### 固定明暗

在上面这一步之后，已经有了一个非常粗略的视图。

所谓固定明暗，并非是「没有光源」。否则你渲染出来的就是一张黑帧。

而我们这一步里面要用到的是一种「不真实」的光；这种光让任何一点光强相同，且反射方式均为漫反射。

> 同样亮度的漫反射啊，让人看起来真实感非常弱。

#### Phong 光照模型

这一步比起上一步就是需要加入真实光照并加入渲染。

* 添加高光

在此之后物体会显得非常光滑，非常不真实（真实世界里没有这种油油亮亮的东西）

* 添加镜面反射

事实上反射并不好操作。实际有两种方法：

1. 用光线跟踪，遇到光反射的时候就反向追踪，找出光线的发射者，并计算反射的光强。这种算法计算量很大，而且在追踪距离较短时效果不好，容易出戏。
2. 用帧缓存中上一帧渲染出来的结果拿出来，略加处理之后当纹理贴到镜子上（咳咳咳）
3. A.O. 游戏里面特别常用的一种方法。

> Question: 是啥？去查！

* 贴图

有些物体有特定的贴图，进行像素级别的计算。

* 凹凸映射

用纹理直接实现非常细小的凹凸变换，而不需要使用几何建模（细小的凹凸不平非常吃计算量的）。

