# 惡補

惡性補習我失去的東西，一切關於著 Compiler。

這個是要答辯的 Lab。佔總成績 20% 的 Lab 5。考慮到 Lab 5 爆炸會連帶著炸掉 Lab 6，可以認為佔總成績的分數是 40%。

## 我需要知道什麼？

 • **src/tiger/frame/.\*** Files related to function stack frame(chapter 6)

 • **src/tiger/translate/.\*** Files related to IR tree translation(chapter 7)

 • **src/tiger/canon/.\*** Files related to basic blocks & traces(chapter 8, this part has already been implemented)

 • **src/tiger/codegen/.\*** Files related to assembly code generation(chapter 9)

 • **src/tiger/runtime/runtime.c** Tiger program runtime file(will be linked with code files generated by your compiler)

 • **src/tiger/env/env.\*** The EnvEntry classes which help compiler store the information of variables&functions

## 我該看哪些章節？

Before you start this lab, you should carefully read the chapter **6, 7, 8, 9, 12** of the textbook.

>    那我開始了。

## Chapter 6: Activation Records

在實現 Tiger 的過程中，主要的難點是支持下面兩個東西：

*   局部變量

    在一個語句塊（Scope）中，要可以訪問在*當前語句塊內*及*上層語句塊內*定義的變量。

*   函數嵌套

    函數像一個普通變量一樣可以嵌套聲明。內層函數體裏可以調用同層及外層函數（這裡的同層包括它自己：遞歸調用）。

    但是為了簡化起見，Tiger 不支持將函數作為返回值。ML 跟 Scheme 等語言都是支持的。

### 6.1 棧幀

需要知道，所謂的這些局部變量、函數等等東西，都是基於一層基本的抽象：棧幀（Stack Frame）。

棧本身不是什麼高級東西；他是一種支持 Push 和 Pop 的數據結構；且總是保證先進後出。

要理解 Stack 本身，只需要想像一層疊放在一起的紙張就好了；總是只能從頂部放一張、或取一張。

---

#### 棧位置

在聲明局部變量時，我們採用一套約定俗成的辦法：

>    在進入 Scope 時將該層級的局部變量成批壓入棧；退出該 Scope 時則按照相反順序成批彈出棧。

但是不像 C89 那種「聲明必須在 Scope 開頭！」的老古董語言，實際上我們可以在語句塊內的任何位置離散地聲明變量。

因此上面的論述可能要改一改了：

>   在進入 Scope 時將該層級的局部變量**所需的空間**成批壓入棧；
>
>   退出該 Scope 時則按照相反順序成批將**佔用的空間**彈出棧。

或者，用我們所熟悉的 `x86-64` 的黑話來講，

>   在進入 Scope 時將 %rsp（指定棧頂位置的指針）減少以分配空間；
>
>   在退出 Scope 時將 %rsp 還原以回收空間。

因此，局部變量的**初始化**是可以在任何部分發生的；

然而其內存的分配及內存位置的確定則是在進入 Scope 時就已知了的。

---

因此，對於編譯型語言 Tiger，一個 Scope 中局部變量所需的內存是在編譯期就能確定的。

>   題外話：在這個 Lab 中，我們不用任何寄存器，因此所有的局部變量都是上棧的。

也就是說，在生成實際代碼之前，Tiger Compiler 需要做到：

*   計算局部變量所佔空間；

    以便在 Scope 開頭結尾放置 `subq %rsp, SIZE` 跟 `addq %rsp, SIZE` 這樣的語句。

*   為**每個**（在這個 Lab 裏，就是每個）變量計算棧內存偏移；

    為了實現藉由 `%rsp(OFFSET)` 樣式的訪存。

`SIZE` 跟 `OFFSET` 都是生成代碼前的定數。

>   題外話：由於歷史原因，棧是倒置的；
>
>   棧頂指針向下（減小），同時棧空間增大；棧頂指針向上（增大），同時棧空間減小。

![image-20191127161435152](27.assets/image-20191127161435152.png)

---

#### 棧幀構造

一般的棧幀應該長什麼樣子呢？

（從高地址位到低地址位）依次是：

---

（上一層棧幀）

*   實參 n
*   實參 n − 1
*   ⋯⋯
*   實參 1
*   靜態鏈（這個是什麼我們待會說） <− 幀指針在此處

---

（本層棧幀）

*   局部變量區域
*   返回地址
*   臨時變量
*   保護的寄存器
*   實參 m
*   實參 m − 1
*   ⋯⋯
*   實參 1
*   靜態鏈 <− 棧指針在此處

---

（下一層棧幀）

---

留意到之所以這裡把上層的棧幀給寫出來，是因為那是根據調用層級來看，那些是上層調用者放好，給這一層看的實際參數。

因此實際上要先放局部變量、返回地址、臨時變量、上棧要保護的寄存器，然後如果要再往深層調用，就要再往上堆下層實際參數和靜態鏈。

另外，在 32 位下，會有 %esp 指針指向棧頂，另有 %ebp 指針指向上一層幀之底。

但是，在 64 位下，%rsp 仍承擔 %esp 的職位；%rbp 則退化為普通寄存器，不再具有幀指針的作用。

當然實際上也沒什麼影響；幀的大小在編譯期（晚期）就能確定（除了 C 的 variable array 之類的奇怪玩意）。

因此 %esp + FRAME_SIZE 也就總是等於 %ebp。這大概就是 %ebp 退休的原因吧。

>   題外話：實際上我們仍然會討論幀指針 %ebp：為什麼？
>
>   因為在編譯過程中，要到比較晚的時候（掃描完整個 Scope）我們才能確定幀大小。
>
>   因此我們在掃描 Scope 的過程中，先使用 %ebp 作為一個標的，等到結束再填入。

---

#### 寄存器

你問我寄存器好不好，當然好啊⋯⋯讀寫速度超快，不用訪存。

就是太少了點。

---

我們按照早期人們的編程習慣，把寄存器分為兩類：

一類是調用者負責存儲的（Caller Saved）；一類是被調用者負責存儲的（Callee Saved）。

簡單說，對於一個剛出生的棧幀來說，被調用者負責存儲的寄存器你可以隨便用；

因為你的上層棧幀一定幫你保存好了，在你死掉的時候還原之；

但是調用者負責存儲的寄存器你要是想用，得先把他們上棧，退出的時候出棧，搞得好麻煩。

而當你想要 Invoke 一個新棧幀的時候，要記得把調用者負責存儲的寄存器給上棧，調用完了之後出棧，搞得好麻煩；

但是被調用者負責存儲的寄存器呢，不用特別處理；那是 Callee 的責任。

簡單說⋯大部分棧幀都是上有老下有小；保存寄存器的責任是對半開的。

上面的事情都是約定俗成；你可以不遵守，但是在跟其他程序混調的時候就可能產生問題。

Use as your own risk.

---

#### 參數傳遞

傳參的方式。

遠古計算機（最早的那一批）是採用一塊固定內存空間來進行參數放置的；

而稍後的古代（20 世紀 70 年代上下）計算機則是將全部的參數都進 Stack 放置。

而考慮到大部分函數調用的參數實際上都不超過十個，因此現代計算機採用「寄存器」+「棧」的組合方式來傳遞參數。

>   優先使用高速寄存器來傳參；寄存器不夠用了再用棧（這個過程稱作 Spill）。

>   當然在這個 Lab 裏，我們始終 Spill 所有參數。按順序（從 n 到 1 倒序）在棧裏排開就好了。

#### 返回地址

為了保證函數調用棧總能返回，我們需要在棧幀結構中記錄下「返回位置」這個重要信息。

>   ret 指令所行之事就是從棧中彈出頂部的一個地址，並跳到那個位置。

所以，在 call 一個函數之前（假設此處的地址為 M），通常會將 M + L（L 是 call 指令的長度） 地址 push 入棧，以確保 ret 函數知道該從哪兒回來。如果不這麼做，就無法保證「棧平衡」。

然而現代計算機中，返回地址是被放在制定寄存器之中，而非在棧幀之中的。

這樣，如果一個函數需要 call 子函數，那麼他就有責任保存這個寄存器的內容到棧幀中，並在退出之前還原其值；反之如果該函數是葉子函數（不用再 call 子函數），那麼就無需保存該寄存器的內容。

#### 棧幀中的變量

講完參數、返回地址，我們就該提一提「局部變量」了。

在一個函數調用的過程中，難免會需要局部變量所佔用的內存區塊。但並非所有的變量都必須放入棧幀，而須滿足如下條件之一：

*   需要對該變量進行取地址操作（如 C/C++ 中的 `&` 運算符）
*   該變量被嵌套在此 Procedure 內的 Procedure 引用了
*   該變量值佔用空間過大而無法放入單個寄存器中
*   該變量是一個數組，引用其內容元素需要對內存尋址
*   局部變量和臨時變量過多，寄存器不夠用而被「Spill」到棧幀中

如果一個變量被作為「引用」（Reference）傳遞給函數，也就是說傳遞的是指針的話，或者一個變量被取了地址，那麼稱這個變量為逃逸的（Escaped），即不可以被放入寄存器的。

實際上，寄存器分配並不是一件很簡單的事；一開始遇到一個變量的時候，並不能夠知道他在之後被引用的情況，也就是沒有足夠的信息來確認分配策略。

一般的編譯器是會先將變量分配道臨時位置，等完全掃描之後再去分配寄存器。

>   在這個 Lab 裏，我們全部往 Stack 上塞。

#### 靜態鏈

棧幀中的最後一塊拼圖就是靜態鏈（Static Link）了。

問題在這裡：Tiger 語言中的嵌套函數，內層函數可以使用外層函數中聲明的變量。

>   Pascal 跟 ML 都是這樣。

實際上有多種方式可以實現嵌套變量的訪問，主要下面三種：

*   靜態鏈：每當調用函數 $f$ 的時候，同時傳給 $f$ 一個指針，指向靜態包含 $f$ 的那個函數。這個指針稱為靜態鏈。如果想要找上層、上上層、⋯⋯的嵌套函數的變量，那麼就必須走靜態鏈跳一次、跳一次、⋯⋯。
*   全局數組：用一個全局的數組來記錄；數組的第 $i$ 個位置放的是最後一次進入的棧幀中嵌套深度為 $i$ 的棧幀位置。這個被稱作嵌套層次顯示表。
*   $\lambda$ 提升：在調用嵌套函數的時候，直接把自己有的局部變量一併發給內層函數，作為額外參數的形式。這個方法稱為 $\lambda$ 提升法。

這裏我們用第一個方法（靜態鏈法）。

每次調用子函數的時候，都把一個指針傳遞給子函數，該指針指向的是程序正文中直接包含該函數的父親函數最近一次進入的活動紀錄。

---

#### Tiger 編譯器的棧幀

有必要留意到：不同的體系結構（Architecture）是有著不同的棧幀結構的。

最簡單的說，不同體系結構指針長度都不一樣。怎麼可能完全一致呢？

因此我們再插入一層抽象（呵呵），通過 `frame.h` 提供操作棧幀的抽象方法，而具體方法則分平台實現。

下面是 Frame 相關的接口：

```c++
typedef struct F_frame_ *F_frame;
typedef struct F_access_ *F_access;
typedef struct F_accessList_ *F_accessList;

struct F_accessList_ {
    F_access head;
    F_accessList tail;
};

F_frame F_newFrame(Temp_label name, U_boolList formals);
Temp_label F_name(F_frame f);
F_accessList F_formals(F_frame f);
F_access F_allocLocal(F_frame f, bool escape);
```

---

#### API 用法

如果我們要調用一個子函數，我們就得為他新開一個棧幀。

使用 `F_newFrame(f, l)` 函數來開。其中 l 是 k 個 Boolean 組成的表，True 表示該位置的參數是逃逸的（看上面的 @escaping 說法），False 則表示非逃逸的。f 則是我們的函數。

因此調用實例是：

```c++
F_newFrame(g, U_BoolList(true, U_BoolList(false, U_BoolList(false, NULL)));
```

>   用遞歸鏈表來保存數組，要麼是這個年代機能有限；要麼是作者腦子有坑。

這樣調用就能返回一個棧幀了。

`F_access` 則是用於訪問存放在棧或僅存起裏的形式參數和局部變量。他是抽象的數據類型，僅在 `Frame` 模塊中可用。

`F_access_` 的定義如下：

```c++
struct F_access_ {
    enum {
        inFrame,
        inReg
    } kind;
    union {
        int offset;		/* if that's stored in frame */
        Temp_temp reg;	/* if that's stored in register */
    } u;
};

static F_access InFrame(int offset);
static F_access InReg(Temp_temp reg);
```

`InFrame(X)`會將一個變量放在相對指針偏移量為 X 的存儲位置（棧中存放該變量的位置）；

`InReg(X)` 會將該變量放在指定的寄存器位置。

重要留意：這些東西都是站在被調用者，也就是子函數的立場上看的。也就是說，按照子函數的幀指針（%rbp）偏移，或者說按照上層調用者的棧指針（%rsp）偏移。同時寄存器也是在子函數進入之後的寄存器分佈，不要按照外層調用者的立場來看。

留意到他們都是抽象的，因此在 `Frame` 模塊之外是不可以訪問他們的。

下一章會提到怎麼在外部 call 她們。

---

`F_formals` 接口函數抽取由 k 個「Call」組成的一張表。每次調用 InFrame 和 InReg 稱為一 Call。在完成 k 次 Call 之後，就可以調用 `F_newFrame` 了。

>   這種調用規則真是**非常不容易出錯**呢

#### 局部變量

局部變量部分上棧，部分進寄存器。

我們怎麼聲明我們這裡有一個局部變量？

通過調用函數 `F_allocLocal(f, BOOLEAN)` 可以聲明我們需要一個局部變量。

BOOLEAN 值設定為 True，即是說明該局部變量是逃逸的，**一定**會被放置在棧空間上，並且該函數會返回棧地址。

BOOLEAN 值設定為 False，則該局部變量是非逃逸的，**可能**會被放置在寄存器中以加速。此時返回值可能是棧地址，也可能是寄存器號。

>   不必要一開棧幀，就調用 `allocLocal`。事實上除了在 C89 中以外，我們基本上可以在任何位置創建局部變量。甚至還可能會因嵌套地創建同名的臨時變量而帶來覆蓋問題。這些都是需要考慮的事情。

#### 計算逃逸變量

非逃逸的局部變量可以被放在寄存器裏，也可以被放在棧幀裏。而逃逸變量則只能放在棧幀裏。

因此，我們關心的是有限制的「逃逸變量」。得想個辦法把他們找出來。確定一個變量是否逃逸，上面已經有明確的規則。

因此我們也有對應的方法來找出哪些逃逸的變量。

```c++
/* escape.h */
void Esc_findEscape(A_exp exp);

/* escape.c */
static void traverseExp(S_table env, int depth, A_exp e);
static void traverseDec(S_table env, int depth, A_dec d);
static void traverseVar(S_table env, int depth, A_var v);
```

留意到，這些函數都是相互遞歸（以及自递归）的。在發現一個逃逸變量的時候，會怎麼做？

他會將 `VarDec` 的 `Escape` 設定為 True。如此，查看 Var 的這個 Field 就能了解他是否逃逸了。

具體的逃逸判斷策略，各語言自然都有區別。可以通過改變 `escape.c/h` 的內容來調整。

---

#### 臨時變量 + 標號

什麼意思？

這裏的臨時變量要區別於前面的局部變量。

局部變量是在程序中明顯給出的變量，其作用域只到當前 Scope 退出為止。

臨時變量則不是在程序中出現的、有名字的變量，而是「虛擬寄存器」的代稱。

>   一定是腦子進水了才會起這麼一個名字。

因此在程序代碼裡，`Temp_temp` 指的就是它了。

在實際指明用哪個寄存器之前，我們可以先用一個抽象層「虛擬寄存器」來確定我們的非逃逸寄存器放哪裡。但虛擬寄存器有個嚴重的區別於寄存器：他不限制個數。有無限個虛擬寄存器可以使用。

然而有另一個東西稱為 Label。label 指的是準確地址還需要確定，但是其值在編譯後運行前就可以確定下來的。比如，某個函數的入口地址；或者之類的東西。

只要使用 `Temp_newtemp()` 函數，就能在無限的虛擬寄存器集合中拿出一個新的給我用。

`Temp_newlabel()` 從標號的無窮集合中拿出一個新的標號給我用。

`Temp_namedlabel(string)` 會返回一個匯編中標號為 string 的標號給我用。

留意到，不同作用域中的名字可能會重複。

---

#### 兩層抽象

我們的 Tiger 編譯器實現過程中有兩層抽象。

Semant -> Translate -> Frame & Temp

Semant 是 Lab 4 裏寫的語義分析。

Translate 是這個 Lab 裏需要實現的指令翻譯。他做的更多的一件事就是處理嵌套作用域的表示。

Frame & Temp 是和實現機器無關的抽象。其實現跟不同的機器的棧幀和寄存器條件有關。

---

#### Translate

Translate 做什麼？他是基於 Semant 的，結構也非常相似。

不同之處在於，Semant 做類型檢查，Translate 做語意轉換。把他們混在一起也不是不可以，只是有點膨脹。

#### Tr 開頭的 API

```c++
typedef struct Tr_access_ *Tr_access;
/* ... 其他 typedef */

Tr_accessList Tr_AccessList(Tr_access head, Tr_accessList tail);
/* 深惡痛絕的鏈表結構 */

Tr_level Tr_outermost(void);
Tr_level Tr_newLevel(Tr_level parent, Temp_label name, U_boolList formals);
Tr_accessList Tr_formals(Tr_level level);
Tr_accessList Tr_allocLocal(Tr_level level, bool escape);
```

現在，在 Tiger 的語意分析階段，我們不能再僅僅提供一個報錯了事，而是要處理好棧幀、寄存器分配之類的事情。

他可以使用的 API 已經很很顯然了：

`Tr_newLevel` 是創建棧幀的函數（調用的當然是 `F_newFrame`）。

嵌套層保存在哪裡呢？一個 `FunEntry` 結構中。這樣，遇到了 Function Call 的時候就可以將這個被調用者的嵌套層交給 Translate。另外，FunEntry 會請求得到函數機器碼入口位置的標號。

```c++
struct E_enventry {
    enum {
        E_varEntry,
        E_funEntry
    } kind;
    union {
        struct {
            Tr_access access;
            Ty_ty ty;
        } var;
        struct {
            Tr_level level;
            Temp_label label;
            Ty_tyList formals;
            Ty_ty result;
        } fun;
    } u;
};

E_enventry E_VarEntry(Tr_access access, Ty_ty ty);
E_enventry E_FunEntry(Tr_level level, Temp_label label,
                     Ty_tyList formals, Ty_ty result);
```

Semant 遇到一個 lev 層的局部變量聲明的時候，他就調用 `Tr_allocLocal(lev, esc)` 函數在 lev 對應的這一層創建變量。esc 參數指定其是否逃逸。

返回值是 `Tr_access`。`Tr_access` 比 `F_access` 要多出了靜態鏈相關的信息。

隨後，如果有一個該層或者是更深層的表達式引用了這個變量，那麼 Semant 就可以請教 Translate 來聲稱訪問到這個變量的機器代碼。同時，Semant 也在每個 VarEntry 裏記錄下這個訪問。

```c++
// inside translate.c
struct Tr_access_ {
    Tr_level level;
    F_access access;
}
```

抽象數據類型 `Tr_access` 記錄每個變量的層級 level 以及他的 `F_access` 組成的對。

---

`Tr_allocLocal` 要調用 `F_allocLocal` 來實現功能，與此同時，還需要記住這個變量生存在那個層次（離開這個層次，該變量就死亡）。最後，如果需要從不同層級訪問這個變量，就需要用到這個 Level 信息來計算靜態鏈。

---

#### 靜態鏈管理

靜態鏈由誰負責？顯然不是 Frame。Frame 應該知道的只是跟語言無關的事情。反映到實際的代碼中，靜態鏈本身也只是棧上的一個數據。這就是 Frame 了解的信息。這件事情應該由 Translate 負責維護。

Translate 才知道關於靜態鏈的信息，每個棧幀有且僅有一個靜態鏈位，並且使用它來完成變量尋址之類的事宜。

考慮到靜態鏈跟變量傳入的參數非常類似，位置也非常類似（挨著的）。所以，我們將其作為形式參數對待為好。

我們直接用 `new_l = U_BoolList(TRUE, l)` 在原來的參數列表外再「套」一個逃逸的「參數」。

>   當然是逃逸的⋯否則靜態鏈放寄存器嗎？

然後，我們採用 `newFrame(label, new_L)` 開一個包含「偽參數」的新棧幀。

如果 f(x, y) 函數被套用在 g 函數之內（g 的層級為 `g_level`），那麼 `transDec` 就可以這麼調用：

```c++
Tr_newLevel(g_level, f, 
           U_BoolList(FALSE, U_BoolList(FALSE, NULL)));

// 假定了 x 跟 y 都是非逃逸的
```

來新開一個棧幀。

 `Tr_newLevel` 則會自動地給形參表多加一個關於靜態鏈的參數，也就是調用 `F_newFrame(label, U_BoolList(TRUE, fmls))` 來創建新的（加入了靜態鏈的）棧幀。

返回值是一個棧幀 `F_Frame`；這個棧幀裏現在就已經有了三個 formals 了；

可以通過 `F_formals(frame)` 來獲取的位移 offset 值；第一個就是靜態鏈的 offset 位移；第二個就是參數 x、y 的 offset 位移。（此處的位移是在棧幀中，相對父親函數的棧指針（自己的幀指針）的偏移量，也就是在實參列表中的偏移量。）

然而在 Semant 調用 `Tr_formals(level)` 的時候，就已經只有兩個位移值了（因為 Translation 主管關於靜態鏈的東西，而且將其嚴格保留在自己以內，不將其擴散。）

---

#### 追蹤層次信息

每次我們調用 `Tr_newLevel` 的時候，Semant 都會提交包圍層的 level（層級）。

但是有沒有想過，主函數（不包含在任何一個函數內的函數）的層次是如何創建的？

要創建這個主函數的層次，就需要獲取他的外層的層次。他的外層還有層次嗎？

>   沒有。

所以我們用 `Tr_outermost()` 函數來指代這個「main 函數的外層」的特殊層次。

>   這個層次裏還有一些實用的庫函數。不是我們這裡的討論範疇。

函數 `transDec` 對每個函數聲明都創建一個新層次。（一層一層的深入。）

`transExp`、`transVar` 也是這樣。而且，他們彼此裏還可能會包含彼此，甚至是自己。

因此，他們都需要一個 `level` 參數。

---

>   End Of Chapter 6.

---

