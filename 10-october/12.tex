% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering

\date{}

\begin{document}

\hypertarget{header-n0}{%
\section{Oct 12 Sat}\label{header-n0}}

今天补上周二的课。Compilers + CSE + RenDie。

噩梦。

\hypertarget{header-n4}{%
\subsection{SE-302::Compilers}\label{header-n4}}

回忆一下我们之前所学到的东西，重新理一理自从 Syntax 之后的内容。

\hypertarget{header-n6}{%
\subsubsection{形式文法}\label{header-n6}}

什么是文法？

Formal Grammar
指的是一套符号和变换规则的组合。这套变换规则也可以叫做「产生式」，因为她的形式就是\textbf{指定了某些符号组合如何被另外一些符号组合替换}。

非终止符（NonTerminal）即为在一个产生式左边的符号，它可以借由这个产生式产生另外的符号列。

反过来不能被「产生式」变换的符号就称为终止符（Terminal）了。

P.S. 变换总得有个开始，因此我们一般指定一个特殊字符 S
作为一个特殊的初始符号来开启所有的变换。如果没有制定
S，那么就认定产生式中第一个非终止符为 S。

\hypertarget{header-n12}{%
\subsubsection{上下文无关文法}\label{header-n12}}

看名字，这是基于形式文法的一种扩展。然而它的特点是基于「产生式」，即变换规则的限制：按照任何一个产生式总可以进行一种「自由」的替换（如
V =\textgreater{} w），即永远可以将字符 V 自由变换为字符串
w，而不需要考虑 V 的上下文。

\hypertarget{header-n14}{%
\subsubsection{悲报}\label{header-n14}}

\begin{verbatim}
2019-10-31

Midterm Exam，在上课教室进行考试。
\end{verbatim}

\hypertarget{header-n16}{%
\subsubsection{Symbol Table}\label{header-n16}}

符号表开了个头。

问题在于：在不同的 Scope
内，符号表是不同的，也就是同一个符号可能代表不同的含义。

我们该如何处理 Scope 事宜呢？

\hypertarget{header-n20}{%
\subsubsection{Binding}\label{header-n20}}

我们比较关心的是每一个符号代表的意义（如符号的类型，值等）。

我们会声明一个形如这样的绑定：s1 = \{A ⟼ int\}，就是把符号跟他的类型
Bind 到一起。

它代表的是符号 A 是个 int 类型的符号。就是这么简单的绑定而已。

随着我们往下扫描整块代码，我们会发现一个个更多的绑定，比如我们会遇到新的变量，形如：

s2 = \{B ⟼ int, A ⟼ int\}

s3 = \{A ⟼ string\}

这样一些其他的绑定。

当我们在内层 Scope 声明了一个和外部 Scope 同名的变量，怎么办呢？

我们会得到两个不同的绑定。但是我们要注意：引用的时候始终按照内层优先。

也就是说，后声明的 Binding 优先生效。

另外注意：在一个 Scope 结束的时候，它内部定义的局部变量（即局部
Binding）应该被清理掉才对。

\hypertarget{header-n32}{%
\subsubsection{Binding 的实现}\label{header-n32}}

现在有两种不同的实现方法：

\begin{itemize}
\item
  函数式风格（Functional Style）

  \begin{itemize}
  \item
    在覆盖一个变量的时候，不修改原来的旧变量，而是新增一个同名变量
  \item
    通过一些「查找顺序」之类的策略来保证 Scope 策略正确
  \end{itemize}
\item
  命令式风格（Imperative Style）

  \begin{itemize}
  \item
    在覆盖一个变量的时候，真实地改掉这个变量，被覆盖的变量消失
  \item
    但是在 Scope 退出的时候，还要 Undo 来回到覆盖之前的状态
  \item
    也就是说，需要维护一个 Undo Stack（撤销栈）
  \end{itemize}
\end{itemize}

事实上两种方法都不是很复杂。

\hypertarget{header-n52}{%
\subsubsection{多重符号表}\label{header-n52}}

特别的，我们有一个「多重符号表」的说法。

考虑到一些高级语言有类似于 \texttt{namespace}
的设计，也就是可能在不同的代码段会有完全不同的符号表。因此我们可能会有多个活跃环境同时存在。

Java 语言中允许向前饮用（Forward Reference）。在同一个 Scope 内部的子
Scope 之前没有先后关系，他们可以互相引用彼此。

\begin{figure}
\centering
\includegraphics{https://raw.githubusercontent.com/yuetsin/private-image-repo/master/2019/10/12-08-24-49-2019-10-12-08-24-46-image.png}
\caption{}
\end{figure}

比如，这里 E、N、D 都会被放入 \texttt{package\ M} 的名字空间。作为 M
的名字空间的一部分，自然 E、N、D
都可以访问彼此，而无论其在源代码中的位置如何。\includegraphics{https://raw.githubusercontent.com/yuetsin/private-image-repo/master/2019/10/12-08-25-02-2019-10-12-08-24-59-image.png}

\hypertarget{header-n58}{%
\subsubsection{高效的命令式风格符号表}\label{header-n58}}

为了高效呢\ldots 我们会使用一个 Open Hash 表（带有外部散列链的散列表）。

Open Hash 表遇到两个 Hash 值撞了的时候，就用链表链长长一串。

但是 Close Hash 不准用链表，要放在一块定大小的数组里面，在满了的时候得
Rehash（重新 Hash 来应付。）。这个实现起来比 Open 的要难很多。

这里我们还是用一个 Open Hash Table。

加入的新的 Symbol 要插在链表的前端；

这样可以保证我们在沿着链表查找的时候，始终会先找到内层 Scope 的 Symbol。

同时我们在恢复原有状态的时候，直接遍历链并进行 \texttt{pop} 就行了。

\hypertarget{header-n66}{%
\subsubsection{高效的函数式风格符号表}\label{header-n66}}

上面的 Imperative 实现本质上还是改变了原来那个表。（往里面插入了一个重复
Key 的
Binding，且在链表的更前端，也就是后面那个永远不可能被访问到，相当于被删除了。）

但我们希望能够保留原有的外层
Namespace，也就是同时保持多个名字空间活跃。如何是好？

这种情况下，直接食用散列表的效率会比较低下。直接 Copy 整个 Hash Table
老费劲了。

我们需要稍微进行一些改进。

或许我们可以不去 Copy 整个 HashTable，而仅仅去拷贝 Array
部分，但修改外部链部分来插入我们的「私货」。类似于这样：

\begin{figure}
\centering
\includegraphics{https://raw.githubusercontent.com/yuetsin/private-image-repo/master/2019/10/12-08-57-37-2019-10-12-08-57-34-image.png}
\caption{}
\end{figure}

右边那一块就是拷贝的 Array，Mouse 就是新加入的 Binding Symbol。

为了让这件事更加高效，我们还是用了
BST（二叉查找树）来存储链，确保每一个节点的访问速度都不会超过
\texttt{log(n)}。

\hypertarget{header-n75}{%
\subsubsection{Tiger 里的实现}\label{header-n75}}

\begin{itemize}
\item
  Tiger 语言中 Symbol 的 Binding 不直接拿字符串来
  Bind，而是直接把指向那个 \texttt{const\ char\ *} 的指针拿来做
  Binding。因为存储多个字符串费空间，而且比较起来还慢。
\item
  使用破坏-更新式 Hash Table（Imperative Style）来对应 Strings 和
  Symbols。
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{#define TABSIZE }\DecValTok{127}
\KeywordTok{typedef} \KeywordTok{struct} \VariableTok{binder_}\NormalTok{ *binder;}
\KeywordTok{struct} \VariableTok{binder_}\NormalTok{ \{}
\NormalTok{    void *key; }\DataTypeTok{void}\NormalTok{ *value;     }\CommentTok{/* a binding */}
\NormalTok{    void *prevtop;              }\CommentTok{/* to implement a stack */}
\NormalTok{    binder next;                }\CommentTok{/* imperative style */}  
\NormalTok{\};}

\KeywordTok{struct}\NormalTok{ TAB_table_ \{}
\NormalTok{      binder table[TABSIZE];}
      \DataTypeTok{void}\NormalTok{ *top;}
\NormalTok{\};}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ TAB_table_ *TAB_table;     }
\end{Highlighting}
\end{Shaded}

\texttt{binder\_} 的 \texttt{key/value} 是很自然的必备字段；

\texttt{binder\_\ *next} 则是用来形成链的指针字段。

而 \texttt{void\ *prevtop} 是给栈这种数据结构用的，也就是实现那个 Undo
Stack 用的。

\hypertarget{header-n85}{%
\paragraph{特殊符号}\label{header-n85}}

\texttt{marksym}: 定义为
\texttt{S\_symbol("\textless{}mark\textgreater{}",\ 0);}
的本不可能出现的 Symbol Binding。

用来标记 Symbol 用的。

\hypertarget{header-n88}{%
\paragraph{BeginScope \& EndScope}\label{header-n88}}

调用 \texttt{S\_beginScope} 的时候，等于是嵌套了一层
Scope，因此加入一个特殊的 MarkSym（对，就是上面那个特殊符号）来标记
Scope 的开始。

于是在调用 \texttt{S\_endScope} 的时候，会持续进行 \texttt{pop}
操作，直到我们遇到那个标记用的 \texttt{MarkSym}。把它也 \texttt{pop}
掉。这样就算除掉了一个 Scope。

\hypertarget{header-n91}{%
\paragraph{两张 Symbol Table}\label{header-n91}}

类型的 Binder 和变量的 Binder 是分开的。

for-type identifier 和 for-value identifier...

大概就是这样的吧。

\hypertarget{header-n95}{%
\paragraph{Type Bindings}\label{header-n95}}

Type 是怎么 Bind 的呢？

我们有一个 \texttt{Ty\_ty\_}...

「类型类型」

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Ty_ty_*     Ty_ty;}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Ty_tyList_* Ty_tyList;}
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Ty_field_* Ty_field }\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ Ty_fieldList_* Ty_fieldList;}
\KeywordTok{struct}\NormalTok{ Ty_ty_ \{}
    \KeywordTok{enum}\NormalTok{ \{ Ty_record, }
\NormalTok{           Ty_nil, }
\NormalTok{           Ty_int, }
\NormalTok{           Ty_string, }
\NormalTok{           Ty_array, }
\NormalTok{           Ty_name, }
\NormalTok{           Ty_void }
\NormalTok{         \} kind;}
    \KeywordTok{union}\NormalTok{ \{}
\NormalTok{        Ty_fieldList record;}
\NormalTok{        Ty_ty        array;}
        \KeywordTok{struct}\NormalTok{ \{}
\NormalTok{            S_symbol sym;}
\NormalTok{            Ty_ty    ty;}
\NormalTok{        \} name;}
\NormalTok{    \} u;}
\NormalTok{\};}

\KeywordTok{struct}\NormalTok{ Ty_tyList_ \{}
\NormalTok{    Ty_ty     head;}
\NormalTok{    Ty_tyList tail;}
\NormalTok{\};}

\KeywordTok{struct}\NormalTok{ Ty_field_ \{}
\NormalTok{    S_symbol name;}
\NormalTok{    Ty_ty    ty;}
\NormalTok{\};}

\NormalTok{Ty_fieldList \{}
\NormalTok{    Ty_field     head;}
\NormalTok{    Ty_fieldList tail;}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

\hypertarget{header-n100}{%
\paragraph{Tiger 的 Type Equivalent}\label{header-n100}}

\begin{verbatim}
 let type a =  { x: int, y:int }
        type b = { x: int, y:int }
        var i : a := …
        var j : b := …
    in i := j
 end /* illegal */

let type a =  { x: int, y:int }
        type c = a
        var i : a := …
        var j : c := …
    in i := j
 end /* legal */
\end{verbatim}

在 Tiger 里头，即使是内存布局完全一致的自定义类型也是不一样的 Type。

但是直接赋值相等的 \texttt{type\ c\ =\ a} ，\texttt{c} 和 \texttt{a}
则可以互相赋值。

\hypertarget{header-n104}{%
\paragraph{Base Environment}\label{header-n104}}

最基本的一个 Environment：啥都还没声明的环境。

这里头放些啥呢？

对于类型来说，int、string 之类的基本数据应该初始化；

\texttt{Ty\_int} 和 \texttt{Ty\_string}，好像 Tiger 也就这两个 built-in
类型（

\hypertarget{header-n109}{%
\paragraph{Function}\label{header-n109}}

作为一个函数，我们在意的包括：

\begin{itemize}
\item
  她的名字
\item
  她的参数列表的类型
\item
  她的返回值
\end{itemize}

Function 跟 Variable 我们都把它们放在变量里面。

用这个枚举值来区分。

\texttt{enum\ \{E\_varEntry,\ E\_funEntry\}\ kind;}

如果是 Function，我们要记录下她的返回值和她的参数列表（formals）。

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef}\NormalTok{ E_enventry_ *E_enventry; }
\KeywordTok{struct}\NormalTok{ E_enventry_ \{}
    \KeywordTok{enum}\NormalTok{ \{ E_varEntry, E_funEntry \} kind;}
    \KeywordTok{union}\NormalTok{ \{}
        \KeywordTok{struct}\NormalTok{ \{ Ty_ty ty; \} var;}
        \KeywordTok{struct}\NormalTok{ \{}
\NormalTok{            Ty_tyList formals; }
\NormalTok{            Ty_ty result;}
\NormalTok{        \} fun;    }
\NormalTok{    \} u;}
\NormalTok{ \};}

\NormalTok{E_enventry E_VarEntry(Ty_ty ty);}
\NormalTok{E_enventry E_FunEntry(Ty_list formals, Ty_ty result);}
\end{Highlighting}
\end{Shaded}

我们也会在 \texttt{base\_env} 里提供一些 built-in Functions，如下：

\begin{figure}
\centering
\includegraphics{https://raw.githubusercontent.com/yuetsin/private-image-repo/master/2019/10/12-09-40-03-2019-10-12-09-40-01-image.png}
\caption{}
\end{figure}

\hypertarget{header-n125}{%
\subsection{SE-227::CSE}\label{header-n125}}

上回啊，咱们说道（说书人腔）\ldots{}

\ldots RPC. Remote Procedure Call.

\begin{quote}
一种用来给 Server 提出请求的方式。
\end{quote}

\ldots NFS. Network File System.

\begin{quote}
一个神奇的网络文件系统。
\end{quote}

\ldots CAP Theorem. Eternal Question.

\begin{quote}
一个不可调和的矛盾\ldots{}
\end{quote}

今天的内容。

\ldots GFS. Google File System. (is it?)

\ldots CDN. Content Distribution Network.

\ldots DNS. Domain Name System.

\hypertarget{header-n140}{%
\subsubsection{RPC}\label{header-n140}}

RPC 并非仅仅用于 NFS 的实现。事实上它的作用要大得多。

例如，Microservices 就是一个例子。

如果我们使用 RPC
作为通信协议，那么就不用特地在意我这个请求是被哪台机器处理的；服务提供者也不用担心每个请求会被哪台机器处理；只需要我们给那些负载较大的请求种类多分配一些资源，就好了。

\hypertarget{header-n144}{%
\paragraph{RPC::Procedure}\label{header-n144}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  客户端调用客户端stub（client
  stub）。这个调用是在本地，并将调用参数push到\href{https://zh.wikipedia.org/wiki/栈}{栈}（stack）中。
\item
  客户端stub（client
  stub）将这些参数包装，并通过系统调用发送到服务端机器。打包的过程叫
  \href{https://zh.wikipedia.org/wiki/Marshalling_(计算机科学)}{marshalling}。（常见方式：\href{https://zh.wikipedia.org/wiki/XML}{XML}、\href{https://zh.wikipedia.org/wiki/JSON}{JSON}、二进制编码）
\item
  客户端本地操作系统发送信息至服务器。（可通过自定义\href{https://zh.wikipedia.org/wiki/传输控制协议}{TCP协议}或\href{https://zh.wikipedia.org/wiki/HTTP}{HTTP}传输）
\item
  服务器系统将信息传送至服务端stub（server stub）。
\item
  服务端stub（server stub）解析信息。该过程叫
  \href{https://zh.wikipedia.org/wiki/Unmarshalling_(计算机科学)}{unmarshalling}。
\item
  服务端stub（server stub）调用程序，并通过类似的方式返回给客户端。
\end{enumerate}

\hypertarget{header-n158}{%
\paragraph{RPC::Failure Handling}\label{header-n158}}

在遇到错误的时候，我们该怎么做？

\hypertarget{header-n160}{%
\subparagraph{At least once}\label{header-n160}}

如果请求失败了，就不断 Retry，Retry，Retry，直到成功为止。

这个问题很大，没个停。万一服务器崩了，这件事情就没完了。

\hypertarget{header-n163}{%
\subparagraph{At most once}\label{header-n163}}

这个问题也比较大；At most once 意味着我们得记住每个历史请求，

才能判断这是否是 Twice or more。

\hypertarget{header-n166}{%
\subparagraph{Exactly once}\label{header-n166}}

理想是 Exactly once。

基本做不到。

\hypertarget{header-n169}{%
\paragraph{Differences}\label{header-n169}}

Client 跟 Server 都需要安全验证。彼此都认为对方是不可信的。

RPC 又名 Web Service。介于 HTTP 和 Socket 之间的抽象。

\hypertarget{header-n172}{%
\subsubsection{GFS}\label{header-n172}}

\hypertarget{header-n173}{%
\paragraph{GFS::Google File System}\label{header-n173}}

谷歌文件系统

\begin{verbatim}
GFS专门为Google的核心数据即页面搜索的存储进行了优化。数据使用大到若干G字节的大文件持续存储，而这些文件极少被删除、覆盖或者减小；通常只是进行添加或读取操作。它也是针对Google的计算机集群进行的设计和优化，这些节点是由廉价的“常用”计算机组成，这就意味着必须防止单个节点的高损害率和随之带来的数据丢失。其它设计理念包括高数据吞吐率，甚至这带来了访问反应期变差。
节点分为两类：主节点和Chunkservers。Chunkservers存储数据文件，这些单个的文件象常见的文件系统中的簇或者扇区那样被分成固定大小的数据块（这也是名字的由来）。每个数据块有一个唯一的64位标签，维护从文件到组成的数据块的逻辑映射。每个数据块在网络上复制一个固定数量的次数，缺省次数是3次，对于常用文件如可执行文件的次数要更多。
主服务器通常并不存储实际的大块数据，而是存储与大块数据相关的元数据，这样的数据如映射表格将64位标签映射到大块数据位置及其组成的文件、大块数据副本位置、哪个进程正在读写特定的大数据块或者追踪复制大块数据的“快照”（通常在主服务器的激发下，当由于节点失败的时候，一个大数据块的副本数目降到了设定的数目下）。所有这些元数据通过主服务器周期性地接收从每个数据块服务器来的更新（“心跳消息”）保持最新状态。
操作的允许授权是通过限时的、倒计时“租期”系统来处理的，主服务器授权一个进程在有限的时间段内访问数据块，在这段时间内主服务器不会授权其它任何进程访问数据块。被更改的chunkserver——总是主要的数据块存储器，然后将更改复制到其它的chunkserver上。这些变化直到所有的chunkserver确认才存储起来，这样就保证了操作的完整性和原子性。
访问大数据块的程序首先查询主服务器得到所要数据块的位置，如果大数据块没有进行操作（没有重要的租约），主服务器回答大数据块的位置，然后程序就可以直接与chunkserver进行联系接收数据（类似于Kazaa和它的超级节点）。
\end{verbatim}

Wiki 上是这么说的\ldots{}

\hypertarget{header-n177}{%
\paragraph{具体的操作}\label{header-n177}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Client 发送请求，带上参数 \texttt{(file\ name,\ chunk\ index)}
\item
  GFS Master 就会通过元数据来找出对应的 Chunk，并给 Chunkserver 发送指令
\item
  Chunkserver 会频繁跟 Master 通信，通过心跳包报告自己还活着
\end{enumerate}

注意：

\begin{itemize}
\item
  这里虽然有一个 filename，但事实上并没有目录这回事。因为保存目录在
  Chunk 里实在太浪费，一层层读取 Chunk 又太慢。所以干脆直接把 file
  的完全路径（如 \texttt{/usr/foo/bar}）给拿来 Hash。这个唤作 Flatten
  Path。
\item
  Chunkserver 有很多个。主服务器聆听这些 Chunkserver 的心跳。
\item
  Master 会成为瓶颈吗？Google 实践说明：并不会。（辩解：）Master
  其实没什么活要干，也不会经常崩；所以 GFS 就只设计了一个 GFS Master。 
\end{itemize}

\hypertarget{header-n193}{%
\paragraph{适用范围}\label{header-n193}}

GFS 专门为 Google 的核心数据即页面搜索的存储进行了优化。数据使用大到若干
GiB 的大文件持续存储，而这些文件极少被删除、覆盖或者减小。

\hypertarget{header-n195}{%
\paragraph{GFS::Cluster}\label{header-n195}}

一个 Master，管理多个 Chunkserver。

Master 只是用来映射 Filename 和 Chunk。

等于是完全把 MetaData 和 Data 分开了。

\begin{verbatim}
操作的允许授权是通过限时的、倒计时“租期”系统来处理的，主服务器授权一个进程在有限的时间段内访问数据块，在这段时间内主服务器不会授权其它任何进程访问数据块。被更改的chunkserver——总是主要的数据块存储器，然后将更改复制到其它的chunkserver上。这些变化直到所有的chunkserver确认才存储起来，这样就保证了操作的完整性和原子性。
访问大数据块的程序首先查询主服务器得到所要数据块的位置，如果大数据块没有进行操作（没有重要的租约），主服务器回答大数据块的位置，然后程序就可以直接与chunkserver进行联系接收数据（类似于Kazaa和它的超级节点）。
\end{verbatim}

每个操作都是「三备份」。写三次！一个 Primary + 两个 Secondary。

而且三个机器都不能放在同一座城市。（核弹可能同时毁掉它们）

这样就不用做 Sink
了！三备份总能够保证有一台机器中存在正确的数据，哪怕他还 Cached
在内存里。能做好错误恢复。

\(P(fail)^3\) 是非常低的。可以忽略。

在 Writer 发现三度写没有成功（没成功写入三个地方）的时候，就会 Retry
Write，直到完成了一次完整的三度写。

\hypertarget{header-n205}{%
\paragraph{GFS::Cache}\label{header-n205}}

GFS Server 本身也不做任何 Cache。缓存这种事情都交给了基层。

基层节点是由\emph{廉价}的「常用」计算机组成。他们来处理自己的 Cache，GFS
本身完全不知道这些事情。

\hypertarget{header-n208}{%
\paragraph{GFS::MetaData}\label{header-n208}}

所有的 MetaData 都存在内存里。

准确点说，存在 Master 的内存里。

\hypertarget{header-n211}{%
\paragraph{GFS 没有\ldots{}}\label{header-n211}}

没有 Link。Hard Soft 都没有。

没有 inode。

没有 Directory。

\hypertarget{header-n215}{%
\paragraph{GFS::ShadowMaster}\label{header-n215}}

为了保证可靠性，通常有一个``影子''主服务器（ShadowMaster）制作主服务器的镜像，一旦主服务器失败它将接替工作。

\hypertarget{header-n217}{%
\subsubsection{CDN}\label{header-n217}}

Content Distribution Network，目的是降低 Load Latency。

服务器：在我知道我的网页要更新之后，我希望我能尽量把这些新数据给 Push
out 到世界各地，使得大家加载起来更快。

客户端：希望能够尽快加载数据，减少带宽压力。

CDN 是互联网中一大批专门用来做 Cache 的服务器。

好处：把 Content 带到离用户更近的地方。

有些数据大量的网站会主动把数据推送给 CDN 以让大家更开心地访问。

\hypertarget{header-n224}{%
\paragraph{DNS \& CDN}\label{header-n224}}

DNS 在知道你要访问某个 IP 时，会分析它能不能被带到更近的地方。

如果发现有个离你更近的 Cached CDN，就会悄悄改掉你请求的
IP，把你的请求重发到另一个 IP 处。

\end{document}
