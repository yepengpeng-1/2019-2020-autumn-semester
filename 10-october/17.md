# Oct 17 Thu

## SE-344::CG

终极目标：得到一帧可显示的图像。其中最重要的一个步骤就是光栅化了。

每一个像素格的颜色都放在一个叫做「帧缓冲存储器」的东西里。

OpenGL 里如何定义那些点及其他基本图元，我们也已经了解到了。

关于点和线这种图元的光栅化所用到的各种算法，我们上节课也讲了。

光栅化完了之后，得到的像素点集合就改名叫 Fragments（片元）了。

### 多边形的光栅化

多边形其实也是 Primitive 的一种的。但是他的光栅化比起点跟线来说，相对更难一些。

#### **最**低效法

逐个检查像素是否在多边形内。丢人！谁会用这种方法

#### 空间连贯性利用法

相邻像素几乎都具有相同的填充状态，只需要在边缘位置进行特别检查和处理。

#####基本步骤

* 求扫描线与多边形边缘的交点
* 对交点排序，分块
* 确定每一块 Span 的填充状态
* 处理特别状态：扫描线掠过顶点时怎么处理

##### 特别说明

为了解决「填充扩大」问题，采用「右上闭左下开」原则，确保多边形绘制结果不扩大。

#### 奇偶扫描转换算法

由上面的空间连贯性扫描线大法衍生而来。每根扫描线存有一个 Bit 标识位，在进入／离开多边形边缘时切换奇偶标识位，并以此标识位决定要不要画像素。

这种算法利用了水平方向的连续性，但却没有用好竖直方向的大体相似性，所以效率有点感人。

#### 有序边表多边形扫描转换算法

这种方法的思路是首先计算出所有的端点及其与扫描线的交点，然后两两取出成对的点构成线段并光栅化。最后得到结果。

#### 采用活化边表的有序边算法

活化边表：不仅仅采用从上到下的扫描顺序，而是根据当前扫描线的位置动态改变边表的内容及顺序，某些根本碰不到扫描线的边就直接从活化边表中剔除，这样可以减少比较次数，提升一定的效率。

#### 边填充算法

每一条跟多边形相交的扫描线，将其交点取为 $(x1, y1)$，把每一条边靠近图形内侧的像素点都填上，最后取交集得到结果。

这个效率是真的很低（×）

#### 栅栏填充算法

所谓 Fence 填充，就是提供一个人为限定的边界，减少那些「不可能」的像素点被 Call 的次数，大大减少了像素点访问次数。稍微提高了点效率。

但还是差（×）

#### 边标识算法

终于有一种适合硬件实现的、好使的算法了（

沿着多边形勾画轮廓线，建立各区段的像素的时候，同时把它们之间的像素也都填上。

这种算法每个像素点访问至多一次。很高效。

#### 种子填充算法

首先指定一个已知在多边形内部的像素点，然后四处找邻居扩散；遇到了边界像素，就撞墙碰壁停止；

##### 4 连通法

只有上下左右的作为邻居。

##### 8 连通法

除了上下左右，右上右下左上左下也可以当作邻居。

通过这种方法，扩散开来填充整个多边形。

一般这种算法用个 Stack 就好了。用递归太浪费，算了。（本质上也是用一个 Callee Stack...）

#### 扫描线种子填充算法

不采用唯一一个像素点来开始种子填充，而是使用一根扫描线找出内部像素全部扔入栈，然后向两边扩展开。

#### 泛滥填充算法

（？？？）这是啥

没有特定边界，把图像中所有满足一定颜色范围的像素点都修改为同一颜色，而不考虑其空间分布。

#### 渐变填充算法

（？？？）好像跑偏了

先确定好他是否是存在于多边形内部的点。然后给定边缘点的颜色，内部其他点的颜色都采用双线性插值确定。

以 $(C1, C2, C3)$ 为例，三个点确定的一个三角形，给这三个点指定三种不同的颜色。

那么对于三角形内部任意一点 $P(x, y)$ 而言，计算出他与三角形的两个交点 $P1(x1, y)$ 和 $P2(x2, y)$。在这条扫描线上，我们认定颜色值就是线性变化的。所以我们只要知道 P1 跟 P2 的颜色值，就可以直接拿到结果了。

那么 P1 跟 P2 的颜色值怎么确定呢？因为 P1 跟 P2 都在直线边界上，所以我们只需要把它的 x 或 y 坐标拿出来同这条边两边的两个端点拿来做插值就可以了！

很简单的一种算法。

> Première

### OpenGL 多边形填充

#### 顶点数据的维护

#####立即模式

~~猴急模式~~

现在几乎没什么人用这种方法了。每创建一个顶点就把它立即发给显卡画。效率是比较低的。

#####VBO／VAO

VBO 是 Vertex Buffer Object 的简称。显卡内的一个内存缓冲区，可以保存顶点、颜色、法线、纹理等等信息。这些信息都还是光栅化之前的图形数据。

VAO 是 Vertex Array Object 的简称。一个 VAO 包含一个或多个 VBO。VAO 会在显存之中线性存储几个对象信息，而不是直接每次都把每一个对象数据发给显卡。这就是 Non-Instant 非立即模式下的工作方法。

#### 指定颜色及其填充方式

使用 `glColor*{*}()` 来指定每个顶点的颜色。

使用 `glShadeModel(GLenum mode)` 来确定颜色的填充方法。

`GL_SMOOTH`：缺省值。使用双线性插值来确定颜色。

`GL_FLAT`：采用离该点最近的顶点的颜色作为该点的颜色。

#### 指定多边形绘制方式

使用 `glPolygonMode(GLenum face, GLenum mode)` 来确定多边形的绘制方式。

Face 的取值范围：

`GL_FRONT`、`GL_BACK`、`GL_FRONT_AND_BACK`，确定对于一个多边形来说是绘制它的正面、背面还是两面都绘制。

Mode 的取值范围：

`GL_POINT` 点填充，只画你说的那几个点

`GL_LINE` 帮你把边给连上

`GL_FILL` 缺省值，帮你填充上多边形。

#### 指定多边形的正反面

`glFrontFace(GL_CCW / GL_CW)` 函数可以做到制定多边形的正面反面。

缺省情况下以右手系作为世界坐标系，逆时针成的面作为正面。

总归记住：面和边都是有方向的。

#### 指定图案填充多边形

`glPolygonStipple(const GLubyte *mask)` 可以用来图案填充多边形。 

### 可见面判别算法

#### 图形的二义性

在投影变换之后，3D 变 2D 之后，深度信息就丢失了，可能同一种投影会产生多种可能的原图形。

那么为了正确地绘制出无二义性的图形，深度信息必不可少。

复杂的情况下，一个图形本身的面、不同的物体之间都会产生遮挡。正确渲染这些面就必须要有深度信息加持。

#### 判定法

##### 画家算法（Naïve 算法）

类似于油画的作画过程；首先把屏幕设定为背景色。然后按照各个面按照视觉距离排序；于是先绘制远景、再画中景；最后画近景。类似于油画颜料的可覆盖性。

问题：一个像素需要被画很多次，效率很低。况且可能有些面可能会倾斜，可能会相交。并不能很好地进行排序。

##### 后向面

或称背向面。指当前视点对应的观察方向所看不到的那些面。

##### 后向面判别算法

设当前观察方向为 $V$，同一个坐标系下，多边形面的法矢为 $N(xn, yn, zn)$。将他们做点乘，在 $V·N>0$ 时，认定他为后向面，隐藏它并不做显示。

##### 深度缓冲器算法

或称作 Depth Buffer Method, Z-Buffer Method.

典型的像空间算法。

对场景中每个物体的每个表面进行处理，对比出深度最大的表面进行显示。

######初始化

$depth(x, y) = 0$。$refresh(x, y) = I(backend)$。

###### 比较

存储比较每个多边形上各点的深度值，并进行可见性判断

###### 计算

计算各个点 $(x, y)$ 处的深度值 $z$；

###### 结果

若 $z > depth(x, y)$，则有

$$depth(x, y) = z; refresh(x, y) = I(surf)(x, y)$$

##### A 缓冲器算法

上面的 DBM 法只能找到一个可见面，也就是说只能处理非透明的表面。没办法处理混合光强值。

对深度缓冲器算法进行了一点扩充：每一个位置都对应着一个 Surface Linked List。链表里就有了当前 Surface 之后的面的信息了。有了这些信息，我们就可以处理光强混合、半透明表面之类的操作了。

##### 扫描线算法

可以处理表面相交的情况了！

##### 光线投影算法

### 反走样技术

Anti-Aliasing Technique

CG 总是会走样的。但我们能不能稍微挽救一下？

#### 采样

> Sampling

走样源自于采样。

采样就是把连续数据转变为离散信息的过程。这就是数据丢失的过程啊。

> 走样 *zǒuyàng* **动**
>
> 失去了原来的样子。
>
> *这双鞋没穿几天就走样了 | 贯彻会议精神不走样。*

采样过程中会失真。失真过于明显，产生走样。

#### Nyquist 采样定理

要想从采样信息中重建原始信号，则采样频率必须大于等于原始信号最大频率的两倍。

#### 反走样技术

用于减少或消除走样效果的技术。也称为抗锯齿算法。也称为 Anti-Aliasing 算法。也称为 AA。

#### 图形反走样

##### 基础思路

把像素作为一个区域，按照区域进行采样。

按照我们栅格化图形的过程中，有的格子是部分落在原图形中的。我们按照占有的比率对其进行灰度级别上色，可以改善人眼的视觉体验。

##### 操作

给定一个最大亮度值，代表完全被覆盖的情况下所对应的颜色。

而那些被部分覆盖的像素点的亮度值设定为（覆盖百分比 × 最大亮度值）。

##### 问题

* 无论像素距离图形有多远，相同的相交面积产生相同的亮度。也就是说离直线的距离这个因素并没有加权。因此还是有比较明显的锯齿效应。
* 直线上的相邻像素点可能产生较大的灰度差。

#### FSAA

全屏反走样技术，Full-Scene Anti-Aliasing。

主要针对 3D 场景的绘制。通过密集的采样和滤波来减少锯齿效应。

FSAA 在渲染一个实际区域的时候（如 1024 × 768）的时候，会事先计算出多倍大小的画面内容（如 4× 抗锯齿，会渲染出 2048 × 1536 的画面），通过密集的采样来进行全屏幕反走样操作。

#### SS

Super Sampling，超级采样。

一个像素当作好几个像素来进行采样。那些「几个像素」就叫做「子像素」（Subpixels）。

渲染的时候场景放大渲染，但是以低分辨率进行显示。低分辨率下每一个像素都是多个像素加权平均的结果。

代价很高。真的很高。

#### OGSS, RGSS, MSAA, Quincunx

SS 的几种实现。

OGSS：顺序栅格采样，按照 x、y 顺序进行采样。

RGSS：旋转栅格采样。

MSAA：多级采样技术，多边形内部无需超采样，因此 MSAA 只在边缘进行超采样，可以节约点时间。

Quincunx：五点梅花采样。每个点的颜色都跟自己周边的颜色有关，且分配有不同的权重。

#### 纹理反走样

####OpenGL 反走样技术

## SE-302::Compilers

$$oh-my-compilers$$

今天要讲的内容是：Activation Records。直译成了活动记录。另一个等价的大白话词语叫做 Frame（栈帧）。

这个 Activation Records 就跟 Function Call 十分相关。每一个 Function 被 call （或者说被 invoke）的时候，都会产生一个正在执行的 Function 的实例。我们把它叫做 Activation。

### Activation

#### Lifetime

Function 的实例，亦即 Activation，是有生命时间的。很自然；函数有执行就有返回。

> 类比：Variable 的 Lifetime。
>
> 变量当然也有 Lifetime；
>
> 一个开在栈上的局部变量在那个 Scope 退出的时候，
>
> 该 Variable 的生命就结束了。

### Memory Layout

内存如何布局？将内存空间分成一块块的。Code 放在最低内存地址位，其他空间放在高内存地址位。

上面提到，活在栈上的 Variable 的 Lifetime 就是由 Stack 顶指针 %rsp 决定的。

那么对于函数的实例 Activation 呢？每一个「活动」的生命是如何被记录、存在的呢？

他们也活在栈上的。

以 Activation Record 的形式。

### Activation Record

#### 简介

事实上 Activation Record 基本要包含这些东西：

* Callee Information

保存着被叫方的信息。

* Caller Information

保存着主叫方的信息。

因为在 Callee 生命结束的时候，控制流要回到 Caller 主叫指令的下一条继续执行。

###高级语言

> 如果某一种语言同时允许：
>
> a) 嵌套式函数定义；
>
> b) 支持把函数作为返回值返回。
>
> 那么就把这门语言定义为「高阶语言」。
>
> Tiger 支持 a) 但是不支持 b)；C 支持 b) 但是不支持 a)。
>
> 典型的高级语言如 ML 等。举例：

```ML
fun f(x) =
	let fun g(y) = x + y
	in g
end
/* nested function decl */

val h = f(3)
val j = f(4)
/* h and j are functions! */

val z = h(5)
val w = j(7)
```

#### Static Link

唯有支持 Static Link（静态链）的语言才能做到 Nested Functions（嵌套式函数定义）。

在调用函数的时候被放在所有参数之前压栈的元素就是 Static Link 的位置。

### Layout Design

编译阶段就需要确定 Frame Layout 的。

各种语言可以自己决定自己的实现；

但是为了让各种语言所编译出的机器码可以做到二进制兼容（Binary Compatible），

大家都不约而同地采用了（几乎）同一种 Layout Design。

我们这里给出的那种 Layout Design（参见 P91 Figure 6-1）是很平凡的。

#### Memory 越来越慢了。

其实不是的，是 SRAM 越来越快，Register 的访问速度比起 Memory 来越来越快了。

因此大家都不太愿意往内存丢东西了，总想着能往 Register 里放的就往 Register 里放。

比如说最新的 MIPS，连函数的返回值都不用栈了，直接丢进了 %rax。

#### Call-by-Value

常用的 C 就是传值式调用，所有的形式参数都只是在栈上分配的临时变量。

对形参的修改仅仅影响了栈，在 Scope 退出之后，就被抹杀掉了，完全影响不了实参。

#### Call-by-Address

或者叫他 Call by Reference。

Fortran 就是这么办的，传给函数的参数并非被在栈上拷贝一份，而是直接把实参的内存地址压栈。Callee 直接拿着这个指针就能修改实参了。

这种情况下，考虑这种调用：

```c++
void foo(int &bar) {
    bar = 1;
}

int i = 0;
foo(i);
// now i = 1.

foo(i + 1);
foo(42);
// ???
```

这里，因为 `i + 1` 不是左值，没办法传他的地址。

这种情况下，Fortran 会创建一个新的临时变量（在 Caller 的栈上），而非在 Callee 的栈上。

这就是奇妙的 Call-by-Reference。

如果我们要做 Reference call，那么这个变量肯定不能放寄存器了（你怎么去 &register 呢？）

#### Call-by-Restore / Copy-in Copy-out

Call by Value 和 Call by Reference 的混合体。

不仅把值在栈上拷了一份，连地址也都压了栈。Callee 写的时候直接改写这些值，在函数 Return 的时候按照这个地址把所有的左值都给写回去。

……这是干什么呢……

#### Myth

我们都是想尽量把参数往寄存器里放的。因为读写内存实在很费时费事。

但是考虑一下这种情况：

```c++
void foo(int a) {
    /* actually foo does nothing. */
    a = a + 1;
};
void bar(int b) {
    foo(42);
};
```

或许我们在调用 bar 的时候，b 可以被放在 Register 里（通常是 %rdi）。

但是我们马上要调用 foo，这时候 %rdi 又要被拿来存储 42 这个数。那咋办呢？

压栈？肯定不行，那就得读写内存了。

放到自己另外的寄存器里？但自己能决定拥有的寄存器是有限的。递归的时候肯定爆了。

放到 Callee-Saved 寄存器里，让子函数来帮我保存？那他一进去可不就是把那些寄存器给压栈么。那不还是有内存访问么。

#### Variable Arguments

可变参数列表。

C/C++ 的经典语法：printf 就拥有一个可变长度的参数列表。

但是有一个特点：它至少有一个参数。

这一个关键参数（格式化字符串，或者类似的东西）可以控制我们怎么解读后面的参数列表。

C/C++ 又提供了一个保证：所有的参数都连续存放。

也就是说不会出现前一半儿参数放在这儿、后一半参数放在那儿、两边不挨着的情况。

主要是因为 C 的标准库中 `varargs` 的实现是基于内存连续寻址的。

所以变长参数列表就很难进入 Registers。至少那一串很难。

###What does the Tiger say?

Tiger 里没有显式的 new。但是，Tiger 中的 Records 和 Arrays 都是放在堆（Heap）里的。

Tiger 中的 Record 和 Array 在作为参数传入的时候，传的都是指针。