% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\usepackage[normalem]{ulem}
% Avoid problems with \sout in headers with hyperref
\pdfstringdefDisableCommands{\renewcommand{\sout}{}}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering

\date{}

\begin{document}

\hypertarget{header-n0}{%
\section{Oct 24 Thu}\label{header-n0}}

\hypertarget{header-n2}{%
\subsection{SE-302::Compilers}\label{header-n2}}

Today Widgets

一点小补充。对应书本 6.2.7：

Keeping Track of Level.

Translate
负责整理静态链相关的问题。考虑到静态链相关的事情都是「语言相关」的东西，所以这些东西不该交给下面的后端，而应该在编译成中间语言之前就解决掉。

留意到 main
函数是个特别的函数。这是一个不位于任何函数内的函数；但应该有权了解到所有位置的变量。

因此在「没有父级的函数」里 call \texttt{Tr\_newlevel} 时，将其定义为
\texttt{Tr\_outermost} 的返回值；这是专为最外层级设计的一个标识。

\hypertarget{header-n9}{%
\subsubsection{Trees Language}\label{header-n9}}

何为树语言？

是一种中间表示（IR, Intermediate Representation）型语言。IR
的目的是在需要将多种语言编译到多种 Target Architecture
的时候，我们可以通过 IR
来做一个中介；以便减少我们犯错的几率，节省工作量。

IR 需要具有这样的条件：

\begin{itemize}
\item
  和具体的语言无关
\item
  足够简单（不能太难翻译和表示）
\item
  功能强大（以便表示各种高级语言）
\item
  和平台无关，能编译到多种 Target Arch。
\end{itemize}

因此我们推出了这一种语言：TreesLang。

TreesLang 已经非常接近底层了；除了在 TreesLang
中有无限的虚拟寄存器可用。

\hypertarget{header-n24}{%
\subsubsection{Expression}\label{header-n24}}

在 Tiger 中，所有的语句都可以作为 Expression。（想想 Lab 3 里的 xxExp）

但是到了 TreesLang 中之后，我们不这么认为了。

主要分为下面 7 类：

\hypertarget{header-n28}{%
\paragraph{Constant}\label{header-n28}}

\texttt{CONST(i)}：整型常数。

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{T_Const(i);}
\end{Highlighting}
\end{Shaded}

\hypertarget{header-n31}{%
\paragraph{Name}\label{header-n31}}

（事实上起的是 Symbolic Constant 的作用）

\texttt{NAME(n)}：符号常数 n，代表了以 n 为名的符号。

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{T_Name(n);}
\end{Highlighting}
\end{Shaded}

\hypertarget{header-n35}{%
\paragraph{Temporary}\label{header-n35}}

（就是上面提到的，无限多的 Virtual Registers）

\texttt{TEMP(t)}：临时变量，或者说虚拟寄存器。

\hypertarget{header-n38}{%
\paragraph{Binary Operation}\label{header-n38}}

（二元操作符，如加减乘除和移位操作等。）

\texttt{BINOP(o,\ e1,\ e2)}：对 e1 和 e2 两个操作数施加 o 操作。

\hypertarget{header-n41}{%
\paragraph{Memory Access}\label{header-n41}}

（访存操作。）

\texttt{MEM(e)}，默认拿出 e 内存地址处的 wordSize 个字节的内容。

\hypertarget{header-n44}{%
\paragraph{Expression Sequence}\label{header-n44}}

（一串儿表达式。）

\texttt{ESEQ(s,\ e)}：考虑到表达式的副作用问题，s 会被先执行，而 e
会被后执行，然后把 e 的返回值作为整个表达式串的返回值返回。

也是为了 Tiger
强加的一个语法（因此要花整个第八章来处理）。正常人类也不用这个。

\hypertarget{header-n48}{%
\paragraph{Procedure Call}\label{header-n48}}

（对函数（或者过程）的调用。）

\texttt{CALL(f,\ l)}：表示过程调用。用参数列表 l 来调用函数 f；但 f
作为函数指针也可能是个表达式。

因此会首先计算 f 内容（如果是一个表达式产生的
Function），再从左到右地计算参数列表；

最后施加调用。

\hypertarget{header-n53}{%
\paragraph{Statement Classifies}\label{header-n53}}

（Statement 是不需要计算出 Value 的表达式，但会产生副作用。）

（如果连副作用都没有，那他有什么意义呢）

\hypertarget{header-n56}{%
\subparagraph{Move}\label{header-n56}}

\texttt{MOVE(TEMP\ t,\ e)}：把 expression 的计算值赋给虚拟寄存器 t。

\texttt{MOVE(MEM(e1),\ e2)}：先计算
e1（Expression），找出指定的内存地址；然后计算
e2，把计算结果赋给该内存地址。

\hypertarget{header-n59}{%
\subparagraph{Expression}\label{header-n59}}

\texttt{EXP(e)}：计算表达式 e
但忽略其结果。（只想要他的副作用。（那这还叫副作用吗？））

\hypertarget{header-n61}{%
\subparagraph{Jump!}\label{header-n61}}

\texttt{JUMP(e,\ labs)}：把控制权交给 e 对应的代码段处。

e 可以是一个 Label；也可以是一个内存地址；也可以是一个
labs（跳转表）的索引。

\texttt{CJUMP(o,\ e1,\ e2,\ t,\ f)}：条件跳转。依次计算出 e1 和 e2
的结果，用 o 对其进行比较；成立时跳转到 t 对应的代码段处；不成立时跳转到
f 对应的代码段处。

\hypertarget{header-n65}{%
\subparagraph{Label}\label{header-n65}}

\texttt{LABEL(n)}：将 n 的值设定为当前机器代码（PC）的地址。

\hypertarget{header-n67}{%
\subsubsection{AST Expressions}\label{header-n67}}

\hypertarget{header-n68}{%
\paragraph{归类}\label{header-n68}}

\begin{itemize}
\item
  Ex::AST Exp that compute values
\end{itemize}

表示为 \texttt{T\_exp}。

\begin{itemize}
\item
  Nx::AST Exp that returns no value
\end{itemize}

表示为 \texttt{T\_stm}。Nx 的意思是：无结果语句。

\begin{itemize}
\item
  Cx::AST Exp with Boolean values
\end{itemize}

仅在 Conditional Jump 时使用。Cx 的意思是：条件语句。

因为我们需要进行 Shortcut
Judgement（短路求值），因此所有的布尔都可以翻译为 Conditional Jump。

\hypertarget{header-n82}{%
\paragraph{问题}\label{header-n82}}

说到短路求值，我们来看个例子。

对于 Tiger 表达式
\texttt{a\ \textgreater{}\ b\ \textbar{}\ c\ \textless{}\ d}，我们按道理应该把它翻成一个
Cx。

但是问题是，在我们翻译完成整条语句之前，我们并不能知道 t
的时候该去哪里、f 的时候该去哪里。

具体的指令位置还远远没定下来。

因此在不了解情况的时候，我们首先将其使用 NULL（or nullptr, if
std\textgreater=c++11。）来填充位置。

等我们知道了之后（这真的在很久之后，至少要生成了汇编代码才知道），再去回填这些数据。

\hypertarget{header-n89}{%
\paragraph{True Patch List \& False Counterpart}\label{header-n89}}

为了保证上面我们的「回填数据法」可以行得通，我们需要维护两张表：

一张「真值标号回填表」；另一张「假值标号回填表」。

表中记录那些「t 已知的时候，应该去填充 NULL 的位置」；

以及「f 已知的时候，应该去填充 NULL 的位置」。

\hypertarget{header-n94}{%
\paragraph{Name := Cx？}\label{header-n94}}

在我们的 Conditional Expression 被拿来当作表达式来赋值的时候，怎么处理？

这相当于是把一个 Cx 当作 Ex 用。

这里有一些 Utility Functions 来做简单表达式类型的转换。

\begin{Shaded}
\begin{Highlighting}[]
\AttributeTok{static}\NormalTok{ T_exp unEx(Tr_exp e);}
\AttributeTok{static}\NormalTok{ T_stm unNx(Tr_exp e);}
\AttributeTok{static} \KeywordTok{struct}\NormalTok{ Cx unCx(Tr_exp e);}
\end{Highlighting}
\end{Shaded}

留意到无论传入的 Tr\_exp 本来为什么类型，三个函数都要能正确处理；

并正确剥离出 T\emph{exp、T}stm 或 struct Cx 的类型。

另外，Cx 的参数为 0 或 1（Constant）时的 trivial
情况应该特别处理；因为可以很容易地减少额外开销。

试图对一个 Tr\_nx 的 exp 进行 unCx 是不合理的。程序应该能处理这种异常。

最简单的办法应该就是：挑一个虚拟寄存器来作为中转\sout{（反正 Virtual
Registers 不要钱）}

然后简单进行一层 Wrapping 就好。

\hypertarget{header-n105}{%
\subsubsection{Translation}\label{header-n105}}

现在我们要真的开始 Translation 了。

\hypertarget{header-n107}{%
\paragraph{Simple Variables}\label{header-n107}}

简单变量的翻译？简单如其名。

\hypertarget{header-n109}{%
\subparagraph{Access Variables}\label{header-n109}}

Tr\emph{Exp Tr}SimpleVar(Tr\emph{Access, Tr}level);

比如，我们这里需要访问一个变量，就只需要把它 Move 到一个 Memory
地址里或虚拟寄存器里就可以了。

为此我们有一个新鲜的 struct：

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{struct}\NormalTok{ Tr_access_ \{}
\NormalTok{	Tr_level level;}
\NormalTok{    F_access access;}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

Tr\_level 是从 environment 中拿到的信息；标识了访问变量的上下文。

F\_access
则是告诉了我们最终应该从哪儿去拿这个变量；寄存器里？内存里？它告诉我们。

\hypertarget{header-n116}{%
\subparagraph{Rules}\label{header-n116}}

尽量不要污染 Semantic
部分。考虑一下我们现在正在做的事情。将生成的语法树变换成中间语言的形式。

这个过程不应该依赖于任何特定语言的 Semantic Analysis，而应该尽可能独立。

不要为了图方便而去用 Semantic 里面开的后门。

\hypertarget{header-n120}{%
\subparagraph{Static Links}\label{header-n120}}

鉴于上一节我们讲过的静态链操作，我们在访问非本级别 Scope
中定义的变量的时候，需要沿着静态链爬 n 步才能到达实际的 Variable 位置。

\hypertarget{header-n122}{%
\paragraph{Subscription \& Field Selection}\label{header-n122}}

访问数组比起访问简单变量来说，要稍微麻烦一些。

对 Tiger 而言，数组访问比起其他语言要更特别一些。

\texttt{a{[}i{]}} =\textgreater{} MEM(+(MEM(e), CONST offset f))。

不像 C 那样，Tiger 的数组名称并不是「指向数组头元素的指针」。

C 中，你不能把一个数组作为 \texttt{:=} 左边的值来赋值。而 Tiger
可以这么做。

数组符号本身是在栈（Stack）上的。然而数组的内容则是分配在堆（Heap）上面的。

在 Scope 退出、数组符号本身被退栈之后，Heap 中的内容会交由 GC
机制来回收（See Chapter 13）。

访问一个 Record 的成员变量，跟 Subscription 也很类似。

只是 offset 的计算方式有别；本质上并无区别。

\texttt{A.f} =\textgreater{} MEM(+(MEM(e), CONST offset f))。

\hypertarget{header-n133}{%
\paragraph{lvalue?}\label{header-n133}}

「Structured Left-Value」::结构化的左值

留意到简单变量名、Subscription 的结果、以及 Field Selection
的结果都是「可被赋值的」。

也就是，可以出现在赋值符号 \texttt{:=} 左边的名字。

同时，类似于 \texttt{42}，\texttt{a\ +\ 2}
之类的值就不是可被赋值的名字。他们不是左值。

虽说叫做左值，但是其实也可以出现在 \texttt{:=}
右边，此时隐含地（Implicitly）作访问其值的意思讲。

技术上来说，左值应该被作为一个 Memory Address 来存储；

出现在赋值号左边时，应该将其作为 Mem. Addr. 来解读；

出现在赋值号右边时，应该隐式地将其解读为这个内存地址里存放的值来解读。

\hypertarget{header-n142}{%
\subsubsection{Criticizing}\label{header-n142}}

\begin{quote}
作者要开始批判一番了
\end{quote}

\hypertarget{header-n145}{%
\paragraph{Bound Checking}\label{header-n145}}

Java 是会对数组的访问去做 Bound Checking（边界检查）的；Java
也根本不提供裸指针用。

然而在编译阶段的时候，在检查通过之后，会消去这部分冗余代码。

\hypertarget{header-n148}{%
\paragraph{Null Checking}\label{header-n148}}

空指针检查：这也是应该执行的检查。

\hypertarget{header-n150}{%
\subsubsection{What does the Tiger say?}\label{header-n150}}

Tiger 里不提供 Unary（原生的负值支持，类似于 -1）。

不提供 Floating Point 的支持。

不提供一元的位操作（如取反）。但却提供了 XoR（跟自己 XoR
也能实现取反操作）

\end{document}
