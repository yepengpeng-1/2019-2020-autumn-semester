# Oct 10 Thu

## SE-227

今天我们要讲的是从头到底的一个服务器搭建。

在服务器所需要提供的服务量越来越大的时候，我们该怎么应对？

1) 买更强的大型机器。

2) 买更多便宜的小机器。

方法 1 很好懂，总归就是烧钱。但总归技术发展是有瓶颈的，单个服务器的能力总归是有限的。

便宜的小机器的限制就小很多。总归小机器很便宜，大不了多买几个就行了。

但问题就来了：如何才能让这么多小机器互相协作呢？

而且，最好是我们不需要改已有的现有代码。

### RPC：Remote Procedure Call

像读写本地文件系统一样，直接读写网络的文件，可以支持多台机器同时连接到网络，并且远程机器会自动加好锁并处理好资源竞争问题。本地只管读，好像这块盘就是本地的一样。

### 如何移植到 RPC？

大概是这样：

Client 只需要这么处理发送给 Server 的请求：

```c++
client->call(protocol::method_name, parameter_1, parameter_2, ...);
```

等价于直接调用

```c++
method_name(parameter_1, parameter_2, ...);
```

但如果说我们不希望修改我们原有的那些代码（也就是不想动那些祖传代码），该怎么办呢？

Stub。打桩。自动生成一些无聊的代码。

截获那些直接的函数调用，把 `method_name` 内部改成 `client->call`，并且处理状态码。

这样就可以保证用户态代码不做任何多余改动，直接就能实现 RPC。

当然 Server 代码也需要对应地修改，只是工作量要小很多。

### Marshalling / Unmarshalling

Marshall 的意思：本意是马歇尔将军的意思，后来被引申到将军、列队、集结、结集、编码、编组、编集、安整、数据打包、列集等稀奇古怪的意思。

因为我们 Client 跟 Server 的函数调用都是美好的、基于函数调用的抽象。然而这种抽象是没办法（直接）在网路上传输并用于 RPC，因为 网络上传输的只能是字节流。

因此为了传输，我们得把这种函数调用给他拍扁了。

C++ 中的参数传递有两种方式：传值和传引用。

但是呢？Client 跟 Server 根本不是一台机器。你传一个 Pointer 或者说是 Reference（本质上也就是一个给小孩子用的 Pointer）都没有意义。

因为你拿着这个 Client 给的指针去 Server，也找不到那个 Object。

所以我们必须把这个 Pointer 指向的 Object 也得拷贝并发送过去。

如果这个 Object 里还有 Pointer…也得一层层 Copy 过去。

深深地拷贝（Deep Copy）这些东西，并打成一个数据包之后，才能通过网络来发送。

这个过程叫做 Marshalling。

反过来，在服务器端要把收到的这些数据包反过来构造成 Object 并重建指针关系的这个过程就叫做 Unmarshalling。


```
Marshal 和 Serialize

"marshal"一个对象意味着记录下它的状态与codebase(s)在这种方式，以便当这个marshal对象在被"unmarshalled"时，可以获得最初代码的一个副本，可能会自动装入这个对象的类定义。可以marshal任何能被序列化或远程（即实现java.rmi.Remote接口）。Marshalling类似序列化，除了marshalling也记录codebases。Marshalling不同于序列化是marshalling特别处理远程对象。
```

看这种机器翻译，就跟看陈浩鹏翻的书一样。就是说你还不如去看英文原版。

### 意义

咱们费了这么大劲，把我们原有的函數調用給改成了「又是發送給遠端服務器，又是列隊又是解散」的，好不容易能用了。那你能不能告訴我這有什麼好處呢？

這都是為了分佈式啊！現在所有的請求全部都變成了異步的請求。這樣就可以讓所有需要等待的事情（如 I/O 等）都拋給服務器來處理，其他的所有東西我們都不用再關心。

### NFS

Network File System。那是啥？

一个分布式的文件系统。

### File Handler

为了处理每一个文件的先后关系，我们总得给他上锁。

假如说我们每次有一个读都去给整个文件系统上锁…那这个效率也太低了。

我们最好单独地给文件上锁，有必要的时候锁上整个目录。

仅仅使用 inode 不能完全确定这个文件。考虑这种情况：

A 来读这个 inode，B 把这个 inode 对应的文件删掉了，C 又创建了一个新文件，刚好又分配到了这个 inode。

那么对于 A 来说，这就是失败了。不正确了。

因此除了 inode，我们还要加一个 Generation Number（代际数），inode 每被分配一次，都会增加一个 Generation Number。

只有 inode Number + Generation Number 才能唯一确认一把锁。

主要原因还是 NFS 是 Stateless 的。无状态确定了它必须要额外的东西（就是这个 Generation Number）来确认状态，就像 HTTP 里的小饼干。

本机是不可能出现这种问题的。 File Description 跟 iNode 是 OS 内记住了的。OS 有记忆。

Stateless NFS 没有。需要 G.N. 帮助。

在我们发现 inode 一样但是 Generation Number 不一样的时候，就返回一个错误「Stale inode Number」，就是说您的 inode number 不新鲜了。

### CAP Theorem

在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer's theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：

* 一致性（Consistency） （等同于所有节点访问同一份最新的数据副本）

* 可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）

* 分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。）

### 幂等操作

一定要保证幂等操作：做 0 次就是做 0 次（没做就是没做），做 N 次（N >= 1）等于做 1 次。

因为事实上互联网的发送包是很不靠谱的。你可能会丢包。

丢包了你就要重发。

但是你认为丢了的包也不一定丢了。

> 或许是对方的 Response 包丢了。

> 或许是对方的 Response 来得比你的 Threshold 晚了一点。

> 或许是对方 Response 要来了的时候，你的机器断电了。在重启之后包已经不在了，你以为没发到其实已经发到了。

就是说你可能失手发了多个一样的包。而且对方也都收到了。

如果不是幂等操作，这种事情就会导致你发出去的包意义变了。

### Eternal Question

永远不知道是对方没收到我的包

还是对方收到了我的包但我却没收到他的回复包。

## SE-344::Computer Graphics

不论你要 Build 出如何真实、如何帅气、如何有意思的图形，

最终你还是要把它给 Render, Flatten 成一个个无趣的像素点的。

这个过程就叫做「光栅化技术」。

---

### 光栅化技術

光栅化之前所有的操作還可以包含 Vertex（頂點）、拓撲關係等等幾何信息；

但光栅化操作會把這些全部拍平；

光栅化之後的所有操作都只能基於 Pixels（像素點）了。

#### 基本圖元繪製算法

我們要瞭解的僅僅就是基礎的算法原理而已。因為目前所有的基礎庫都很好地替我們提供了優秀的實現，我們不必要自己實現這些算法。

（雖然在下次作業裡，我們還是會需要做它一次。）

#### 圖形的表示

* WireFrame，線框模型

僅僅採用頂點和鄰邊來表示模型。

如果只有三維的線框模型的話，這種表示是存在二義性的。由於不存在遮擋關係，沒辦法唯一地表現出空間的。

只是快速表示一下空間而已。

* Surface，表面模型

這種表示方法相較於 WireFrame，是由很多個 Surface（面片）搭建成的。由於面片之間存在遮擋關係，因此就表示精確度而言高於 WireFrame 模型。

但他沒有說明這圖形是由表面的哪一邊組成的。

* Solid，實體模型

這種模型表示方法是可以定義形體處於表面的哪一側的。

還有很多種圖形的表示方法：

* 表面多邊形法（B-rep）
* 解析法、微分法
* 掃描表示法
* 四叉樹、八叉樹表示法
* 分形幾何法
* 粒子系統（Particle System）

#### 圖形的顯示

顯示跟表示是不一樣的。

顯示文件僅僅是整個圖形表示的一部分。

---


取景窗口也决定了显示的内容。这个取景窗口的决定叫做 Clipping。

* 每一个可以独立显示的点叫做像素点「Pixel Points」。
* 一行像素构成一条光栅（Raster），也叫做扫描线（Scanline）。

确定屏幕上像素点的集合和颜色，叫做光栅化（Rasterization），也叫做扫描线算法（Scanline Algorithms）。


多年以前的 CRT 显示器需要扫描显示。因此它就有两种不同的扫描方法：

* 奇数场优先；

奇数场优先就是优先画出奇数场的扫描线，然后回扫；（回到第一个地方）而偶数场的扫描线就先暂且留在上一帧的位置。

* 偶数场优先；

和奇数场优先相反。

* 逐行显示

不区分上下／奇偶场。

#### 帧缓冲存储器

存储器中包含了每个像素的信息。

拿出对应像素点的信息，放到对应的寄存器（Register）之中，然后送给显示控制器来干活；最终显示出来。

彩色的呢复杂一点。

有三个独立的显示控制器（R/G/B）共同显示彩色。

因此就需要三重显示控制器。

> P.S. 部分的显示系统还包括了 Alpha 通道（也就是不透明度的控制）。但是并不存在一种「Alpha 显示控制器」。在此之前他就已经被平摊到 R/G/B 通道上了。

### OpenGL 的基本图元绘制

#### 定义顶点

顶点是一切东西的开始和基础。

由它才产生出了点、线、多边形，等等。

##### `glVertex*`

> `*` 代表这个函数有后缀。合理的后缀形似：

* glVertex2i

2 代表这个顶点在二维空间之中。

i 代表这个点的坐标值为整数。

s 代表这个点的坐标值为段整数。

* glVertex3f

3 代表这个顶点在三维空间之中。

f 代表这个点的坐标值为单精度浮点数。

d 代表这个点的坐标值为双精度浮点数。

以此类推。

```c++
glBegin(GL_POINTS);

...

glEnd();
```

`glBegin` 和 `glEnd` 之间的部分就是我们定义的顶点们。

glBegin 中有一些参数，决定了怎么处理 glBegin 和 glEnd 之间定义的图元。

参数去看 PPT。这里记不下来。

#### Example

```c++

glClear(GL_COLOR_BUFFER_BIT);

glColor3f(0.2, 0.7, 0.7);

glPointSize(5.0);

glBegin(GL_POINTS);

glVertex2f(0.0, 2.0);

...

glEnd();

glFlush();

```
P.S. 可以在 `glBegin()` 和 `glEnd()` 之间通过 `glColor3f` 来修改顶点的颜色。

不同的顶点颜色组装在一起会产生渐变颜色效果。这是双线性插值的结果。以后会讲到。

### 基本图元光栅化算法

最基本的事情。我们都很关心。

#### 啥是基本图元啊？

Primitive Symbols。什么算基本？

点、线、圆、一般函数曲线、字符。

#### 光栅化／扫描线算法

把原来的一个美好的几何图形给拍扁成一堆像素点。

这个过程就是光栅化／扫描线算法。

#### Fragment：片元

光栅化完成之后，原来那个图元对应的像素点集合就叫片元区域。

#### 光栅化

##### 点的光栅化

P(x0, y0) 怎么变呢？

> 法一：直接取整数部分。

> 法二：四舍五入。

这两者区别不太大，但是总的来说四舍五入的像素点偏移会更少。

如果说直接取整数部分，有可能会产生整体像左下角（0, 0 位置）的偏移。

但总归，点的光栅化都是容易的。

##### 直线的光栅化

在数学中，直线的斜截式方程为 $y = k x + b$。

但事实上计算机不会处理无限长的直线。它只会处理有限的线段。

因此我们一般会提供起点和终点 P1(x1, y1) - P2(x2, y2)。只画这两点构成的线段。

平凡的四种线段：$y = k$，$x = k$，$x = y$，$x = -y$。这个光栅化过于简单，不多谈。

我们可以直接把它简化为点的光栅化问题。把这个线段给切分成一些点的集合（按照一定的切分粒度），然后对每一个点进行光栅化。

在斜率 k 绝对值小于 1 的时候就用变化的 x 来求 y。

在 k 绝对值大于 1 的时候就用变化的 y 来求 x。

但这个算法非常之慢。正常人类不会用的。

##### 直线的光栅化（人类的方法）

DDA 算法：Digital Difference Algorithm。

这是一个增量计算法；也就是每一步计算都跟上一步的计算结果有关系。

我们知道起点和终点；先把起点给光栅化掉再说。

然后我们就有了另一个参量：当前绘制的点。

我们判断这个当前点是偏向了 y 轴（向上偏了）还是偏向了 x 轴（向下偏了）。

如果斜率偏小，那下一步就往右走；如果斜率偏大，那下一步就往上走。

如果不偏不倚；刚好一样，那就往右上方走。

这么办可以保证比较高的效率，同时 trivial 的四种情况也可以直接处理掉。

当然这种方法就仅仅适用于直线而已。其他的曲线是不可以用的。