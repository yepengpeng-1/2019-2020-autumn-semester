# Oct 10 Thu

## SE-227

今天我们要讲的是从头到底的一个服务器搭建。

在服务器所需要提供的服务量越来越大的时候，我们该怎么应对？

1) 买更强的大型机器。

2) 买更多便宜的小机器。

方法 1 很好懂，总归就是烧钱。但总归技术发展是有瓶颈的，单个服务器的能力总归是有限的。

便宜的小机器的限制就小很多。总归小机器很便宜，大不了多买几个就行了。

但问题就来了：如何才能让这么多小机器互相协作呢？

而且，最好是我们不需要改已有的现有代码。

### RPC：Remote Procedure Call

像读写本地文件系统一样，直接读写网络的文件，可以支持多台机器同时连接到网络，并且远程机器会自动加好锁并处理好资源竞争问题。本地只管读，好像这块盘就是本地的一样。

### 如何移植到 RPC？

大概是这样：

Client 只需要这么处理发送给 Server 的请求：

```
client->call(protocol::method_name, parameter_1, parameter_2, ...);
```

等价于直接调用

```
method_name(parameter_1, parameter_2, ...);
```

但如果说我们不希望修改我们原有的那些代码（也就是不想动那些祖传代码），该怎么办呢？

Stub。打桩。自动生成一些无聊的代码。

截获那些直接的函数调用，把 `method_name` 内部改成 `client->call`，并且处理状态码。

这样就可以保证用户态代码不做任何多余改动，直接就能实现 RPC。

当然 Server 代码也需要对应地修改，只是工作量要小很多。

### Marshalling / Unmarshalling

Marshall 的意思：本意是马歇尔将军的意思，后来被引申到将军、列队、集结、结集、编码、编组、编集、安整、数据打包、列集等稀奇古怪的意思。

因为我们 Client 跟 Server 的函数调用都是美好的、基于函数调用的抽象。然而这种抽象是没办法（直接）在网路上传输并用于 RPC，因为 网络上传输的只能是字节流。

因此为了传输，我们得把这种函数调用给他拍扁了。

C++ 中的参数传递有两种方式：传值和传引用。

但是呢？Client 跟 Server 根本不是一台机器。你传一个 Pointer 或者说是 Reference（本质上也就是一个给小孩子用的 Pointer）都没有意义。

因为你拿着这个 Client 给的指针去 Server，也找不到那个 Object。

所以我们必须把这个 Pointer 指向的 Object 也得拷贝并发送过去。

如果这个 Object 里还有 Pointer…也得一层层 Copy 过去。

深深地拷贝（Deep Copy）这些东西，并打成一个数据包之后，才能通过网络来发送。

这个过程叫做 Marshalling。

反过来，在服务器端要把收到的这些数据包反过来构造成 Object 并重建指针关系的这个过程就叫做 Unmarshalling。


```
Marshal 和 Serialize

"marshal"一个对象意味着记录下它的状态与codebase(s)在这种方式，以便当这个marshal对象在被"unmarshalled"时，可以获得最初代码的一个副本，可能会自动装入这个对象的类定义。可以marshal任何能被序列化或远程（即实现java.rmi.Remote接口）。Marshalling类似序列化，除了marshalling也记录codebases。Marshalling不同于序列化是marshalling特别处理远程对象。
```

看这种机器翻译，就跟看陈浩鹏翻的书一样。就是说你还不如去看英文原版。

