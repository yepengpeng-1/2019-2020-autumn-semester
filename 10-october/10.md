# Oct 10 Thu

## SE-227

今天我们要讲的是从头到底的一个服务器搭建。

在服务器所需要提供的服务量越来越大的时候，我们该怎么应对？

1) 买更强的大型机器。

2) 买更多便宜的小机器。

方法 1 很好懂，总归就是烧钱。但总归技术发展是有瓶颈的，单个服务器的能力总归是有限的。

便宜的小机器的限制就小很多。总归小机器很便宜，大不了多买几个就行了。

但问题就来了：如何才能让这么多小机器互相协作呢？

而且，最好是我们不需要改已有的现有代码。

### RPC：Remote Procedure Call

像读写本地文件系统一样，直接读写网络的文件，可以支持多台机器同时连接到网络，并且远程机器会自动加好锁并处理好资源竞争问题。本地只管读，好像这块盘就是本地的一样。

### 如何移植到 RPC？

大概是这样：

Client 只需要这么处理发送给 Server 的请求：

```
client->call(protocol::method_name, parameter_1, parameter_2, ...);
```

等价于直接调用

```
method_name(parameter_1, parameter_2, ...);
```

但如果说我们不希望修改我们原有的那些代码（也就是不想动那些祖传代码），该怎么办呢？

Stub。打桩。自动生成一些无聊的代码。

截获那些直接的函数调用，把 `method_name` 内部改成 `client->call`，并且处理状态码。

这样就可以保证用户态代码不做任何多余改动，直接就能实现 RPC。

当然 Server 代码也需要对应地修改，只是工作量要小很多。

### Marshalling / Unmarshalling

Marshall 的意思：本意是马歇尔将军的意思，后来被引申到将军、列队、集结、结集、编码、编组、编集、安整、数据打包、列集等稀奇古怪的意思。

因为我们 Client 跟 Server 的函数调用都是美好的、基于函数调用的抽象。然而这种抽象是没办法（直接）在网路上传输并用于 RPC，因为 网络上传输的只能是字节流。

因此为了传输，我们得把这种函数调用给他拍扁了。

C++ 中的参数传递有两种方式：传值和传引用。

但是呢？Client 跟 Server 根本不是一台机器。你传一个 Pointer 或者说是 Reference（本质上也就是一个给小孩子用的 Pointer）都没有意义。

因为你拿着这个 Client 给的指针去 Server，也找不到那个 Object。

所以我们必须把这个 Pointer 指向的 Object 也得拷贝并发送过去。

如果这个 Object 里还有 Pointer…也得一层层 Copy 过去。

深深地拷贝（Deep Copy）这些东西，并打成一个数据包之后，才能通过网络来发送。

这个过程叫做 Marshalling。

反过来，在服务器端要把收到的这些数据包反过来构造成 Object 并重建指针关系的这个过程就叫做 Unmarshalling。


```
Marshal 和 Serialize

"marshal"一个对象意味着记录下它的状态与codebase(s)在这种方式，以便当这个marshal对象在被"unmarshalled"时，可以获得最初代码的一个副本，可能会自动装入这个对象的类定义。可以marshal任何能被序列化或远程（即实现java.rmi.Remote接口）。Marshalling类似序列化，除了marshalling也记录codebases。Marshalling不同于序列化是marshalling特别处理远程对象。
```

看这种机器翻译，就跟看陈浩鹏翻的书一样。就是说你还不如去看英文原版。

### 意义

咱们费了这么大劲，把我们原有的函數調用給改成了「又是發送給遠端服務器，又是列隊又是解散」的，好不容易能用了。那你能不能告訴我這有什麼好處呢？

這都是為了分佈式啊！現在所有的請求全部都變成了異步的請求。這樣就可以讓所有需要等待的事情（如 I/O 等）都拋給服務器來處理，其他的所有東西我們都不用再關心。

### NFS

Network File System。那是啥？

一个分布式的文件系统。

### File Handler

为了处理每一个文件的先后关系，我们总得给他上锁。

假如说我们每次有一个读都去给整个文件系统上锁…那这个效率也太低了。

我们最好单独地给文件上锁，有必要的时候锁上整个目录。

仅仅使用 inode 不能完全确定这个文件。考虑这种情况：

A 来读这个 inode，B 把这个 inode 对应的文件删掉了，C 又创建了一个新文件，刚好又分配到了这个 inode。

那么对于 A 来说，这就是失败了。不正确了。

因此除了 inode，我们还要加一个 Generation Number（代际数），inode 每被分配一次，都会增加一个 Generation Number。

只有 inode Number + Generation Number 才能唯一确认一把锁。

主要原因还是 NFS 是 Stateless 的。无状态确定了它必须要额外的东西（就是这个 Generation Number）来确认状态，就像 HTTP 里的小饼干。

本机是不可能出现这种问题的。 File Description 跟 iNode 是 OS 内记住了的。OS 有记忆。

Stateless NFS 没有。

### CAP Theorem

在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer's theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：

* 一致性（Consistency） （等同于所有节点访问同一份最新的数据副本）

* 可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）

* 分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。）

