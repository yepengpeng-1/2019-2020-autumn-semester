% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\newenvironment{Shaded}{}{}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{#1}}}}
\usepackage[normalem]{ulem}
% Avoid problems with \sout in headers with hyperref
\pdfstringdefDisableCommands{\renewcommand{\sout}{}}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering

\date{}

\begin{document}

\hypertarget{header-n0}{%
\section{Oct 17 Thu}\label{header-n0}}

\hypertarget{header-n2}{%
\subsection{SE-344::CG}\label{header-n2}}

终极目标：得到一帧可显示的图像。其中最重要的一个步骤就是光栅化了。

每一个像素格的颜色都放在一个叫做「帧缓冲存储器」的东西里。

OpenGL 里如何定义那些点及其他基本图元，我们也已经了解到了。

关于点和线这种图元的光栅化所用到的各种算法，我们上节课也讲了。

光栅化完了之后，得到的像素点集合就改名叫 Fragments（片元）了。

\hypertarget{header-n8}{%
\subsubsection{多边形的光栅化}\label{header-n8}}

多边形其实也是 Primitive
的一种的。但是他的光栅化比起点跟线来说，相对更难一些。

\hypertarget{header-n10}{%
\paragraph{\texorpdfstring{\textbf{最}低效法}{最低效法}}\label{header-n10}}

逐个检查像素是否在多边形内。丢人！谁会用这种方法

\hypertarget{header-n12}{%
\paragraph{空间连贯性利用法}\label{header-n12}}

相邻像素几乎都具有相同的填充状态，只需要在边缘位置进行特别检查和处理。

\hypertarget{header-n14}{%
\subparagraph{基本步骤}\label{header-n14}}

\begin{itemize}
\item
  求扫描线与多边形边缘的交点
\item
  对交点排序，分块
\item
  确定每一块 Span 的填充状态
\item
  处理特别状态：扫描线掠过顶点时怎么处理
\end{itemize}

\hypertarget{header-n24}{%
\subparagraph{特别说明}\label{header-n24}}

为了解决「填充扩大」问题，采用「右上闭左下开」原则，确保多边形绘制结果不扩大。

\hypertarget{header-n26}{%
\paragraph{奇偶扫描转换算法}\label{header-n26}}

由上面的空间连贯性扫描线大法衍生而来。每根扫描线存有一个 Bit
标识位，在进入／离开多边形边缘时切换奇偶标识位，并以此标识位决定要不要画像素。

这种算法利用了水平方向的连续性，但却没有用好竖直方向的大体相似性，所以效率有点感人。

\hypertarget{header-n29}{%
\paragraph{有序边表多边形扫描转换算法}\label{header-n29}}

这种方法的思路是首先计算出所有的端点及其与扫描线的交点，然后两两取出成对的点构成线段并光栅化。最后得到结果。

\hypertarget{header-n31}{%
\paragraph{采用活化边表的有序边算法}\label{header-n31}}

活化边表：不仅仅采用从上到下的扫描顺序，而是根据当前扫描线的位置动态改变边表的内容及顺序，某些根本碰不到扫描线的边就直接从活化边表中剔除，这样可以减少比较次数，提升一定的效率。

\hypertarget{header-n33}{%
\paragraph{边填充算法}\label{header-n33}}

每一条跟多边形相交的扫描线，将其交点取为
\((x1, y1)\)，把每一条边靠近图形内侧的像素点都填上，最后取交集得到结果。

这个效率是真的很低（×）

\hypertarget{header-n36}{%
\paragraph{栅栏填充算法}\label{header-n36}}

所谓 Fence
填充，就是提供一个人为限定的边界，减少那些「不可能」的像素点被 Call
的次数，大大减少了像素点访问次数。稍微提高了点效率。

但还是差（×）

\hypertarget{header-n39}{%
\paragraph{边标识算法}\label{header-n39}}

终于有一种适合硬件实现的、好使的算法了（

沿着多边形勾画轮廓线，建立各区段的像素的时候，同时把它们之间的像素也都填上。

这种算法每个像素点访问至多一次。很高效。

\hypertarget{header-n43}{%
\paragraph{种子填充算法}\label{header-n43}}

首先指定一个已知在多边形内部的像素点，然后四处找邻居扩散；遇到了边界像素，就撞墙碰壁停止；

\hypertarget{header-n45}{%
\subparagraph{4 连通法}\label{header-n45}}

只有上下左右的作为邻居。

\hypertarget{header-n47}{%
\subparagraph{8 连通法}\label{header-n47}}

除了上下左右，右上右下左上左下也可以当作邻居。

通过这种方法，扩散开来填充整个多边形。

一般这种算法用个 Stack 就好了。用递归太浪费，算了。（本质上也是用一个
Callee Stack...）

\hypertarget{header-n51}{%
\paragraph{扫描线种子填充算法}\label{header-n51}}

不采用唯一一个像素点来开始种子填充，而是使用一根扫描线找出内部像素全部扔入栈，然后向两边扩展开。

\hypertarget{header-n53}{%
\paragraph{泛滥填充算法}\label{header-n53}}

（？？？）这是啥

没有特定边界，把图像中所有满足一定颜色范围的像素点都修改为同一颜色，而不考虑其空间分布。

\hypertarget{header-n56}{%
\paragraph{渐变填充算法}\label{header-n56}}

（？？？）好像跑偏了

先确定好他是否是存在于多边形内部的点。然后给定边缘点的颜色，内部其他点的颜色都采用双线性插值确定。

以 \((C1, C2, C3)\)
为例，三个点确定的一个三角形，给这三个点指定三种不同的颜色。

那么对于三角形内部任意一点 \(P(x, y)\) 而言，计算出他与三角形的两个交点
\(P1(x1, y)\) 和
\(P2(x2, y)\)。在这条扫描线上，我们认定颜色值就是线性变化的。所以我们只要知道
P1 跟 P2 的颜色值，就可以直接拿到结果了。

那么 P1 跟 P2 的颜色值怎么确定呢？因为 P1 跟 P2
都在直线边界上，所以我们只需要把它的 x 或 y
坐标拿出来同这条边两边的两个端点拿来做插值就可以了！

很简单的一种算法。

\begin{quote}
Première
\end{quote}

\hypertarget{header-n65}{%
\subsubsection{OpenGL 多边形填充}\label{header-n65}}

\hypertarget{header-n66}{%
\paragraph{顶点数据的维护}\label{header-n66}}

\hypertarget{header-n67}{%
\subparagraph{立即模式}\label{header-n67}}

\sout{猴急模式}

现在几乎没什么人用这种方法了。每创建一个顶点就把它立即发给显卡画。效率是比较低的。

\hypertarget{header-n70}{%
\subparagraph{VBO／VAO}\label{header-n70}}

VBO 是 Vertex Buffer Object
的简称。显卡内的一个内存缓冲区，可以保存顶点、颜色、法线、纹理等等信息。这些信息都还是光栅化之前的图形数据。

VAO 是 Vertex Array Object 的简称。一个 VAO 包含一个或多个 VBO。VAO
会在显存之中线性存储几个对象信息，而不是直接每次都把每一个对象数据发给显卡。这就是
Non-Instant 非立即模式下的工作方法。

\hypertarget{header-n73}{%
\paragraph{指定颜色及其填充方式}\label{header-n73}}

使用 \texttt{glColor*\{*\}()} 来指定每个顶点的颜色。

使用 \texttt{glShadeModel(GLenum\ mode)} 来确定颜色的填充方法。

\texttt{GL\_SMOOTH}：缺省值。使用双线性插值来确定颜色。

\texttt{GL\_FLAT}：采用离该点最近的顶点的颜色作为该点的颜色。

\hypertarget{header-n78}{%
\paragraph{指定多边形绘制方式}\label{header-n78}}

使用 \texttt{glPolygonMode(GLenum\ face,\ GLenum\ mode)}
来确定多边形的绘制方式。

Face 的取值范围：

\texttt{GL\_FRONT}、\texttt{GL\_BACK}、\texttt{GL\_FRONT\_AND\_BACK}，确定对于一个多边形来说是绘制它的正面、背面还是两面都绘制。

Mode 的取值范围：

\texttt{GL\_POINT} 点填充，只画你说的那几个点

\texttt{GL\_LINE} 帮你把边给连上

\texttt{GL\_FILL} 缺省值，帮你填充上多边形。

\hypertarget{header-n86}{%
\paragraph{指定多边形的正反面}\label{header-n86}}

\texttt{glFrontFace(GL\_CCW\ /\ GL\_CW)}
函数可以做到制定多边形的正面反面。

缺省情况下以右手系作为世界坐标系，逆时针成的面作为正面。

总归记住：面和边都是有方向的。

\hypertarget{header-n90}{%
\paragraph{指定图案填充多边形}\label{header-n90}}

\texttt{glPolygonStipple(const\ GLubyte\ *mask)}
可以用来图案填充多边形。

\hypertarget{header-n92}{%
\subsubsection{可见面判别算法}\label{header-n92}}

\hypertarget{header-n93}{%
\paragraph{图形的二义性}\label{header-n93}}

在投影变换之后，3D 变 2D
之后，深度信息就丢失了，可能同一种投影会产生多种可能的原图形。

那么为了正确地绘制出无二义性的图形，深度信息必不可少。

复杂的情况下，一个图形本身的面、不同的物体之间都会产生遮挡。正确渲染这些面就必须要有深度信息加持。

\hypertarget{header-n97}{%
\paragraph{判定法}\label{header-n97}}

\hypertarget{header-n98}{%
\subparagraph{画家算法（Naïve 算法）}\label{header-n98}}

类似于油画的作画过程；首先把屏幕设定为背景色。然后按照各个面按照视觉距离排序；于是先绘制远景、再画中景；最后画近景。类似于油画颜料的可覆盖性。

问题：一个像素需要被画很多次，效率很低。况且可能有些面可能会倾斜，可能会相交。并不能很好地进行排序。

\hypertarget{header-n101}{%
\subparagraph{后向面}\label{header-n101}}

或称背向面。指当前视点对应的观察方向所看不到的那些面。

\hypertarget{header-n103}{%
\subparagraph{后向面判别算法}\label{header-n103}}

设当前观察方向为 \(V\)，同一个坐标系下，多边形面的法矢为
\(N(xn, yn, zn)\)。将他们做点乘，在 \(V·N>0\)
时，认定他为后向面，隐藏它并不做显示。

\hypertarget{header-n105}{%
\subparagraph{深度缓冲器算法}\label{header-n105}}

或称作 Depth Buffer Method, Z-Buffer Method.

典型的像空间算法。

对场景中每个物体的每个表面进行处理，对比出深度最大的表面进行显示。

初始化

\(depth(x, y) = 0\)。\(refresh(x, y) = I(backend)\)。

比较

存储比较每个多边形上各点的深度值，并进行可见性判断

计算

计算各个点 \((x, y)\) 处的深度值 \(z\)；

结果

若 \(z > depth(x, y)\)，则有

\(depth(x, y) = z; refresh(x, y) = I(surf)(x, y)\)

\hypertarget{header-n118}{%
\subparagraph{A 缓冲器算法}\label{header-n118}}

上面的 DBM
法只能找到一个可见面，也就是说只能处理非透明的表面。没办法处理混合光强值。

对深度缓冲器算法进行了一点扩充：每一个位置都对应着一个 Surface Linked
List。链表里就有了当前 Surface
之后的面的信息了。有了这些信息，我们就可以处理光强混合、半透明表面之类的操作了。

\hypertarget{header-n121}{%
\subparagraph{扫描线算法}\label{header-n121}}

可以处理表面相交的情况了！

\hypertarget{header-n123}{%
\subparagraph{光线投影算法}\label{header-n123}}

\hypertarget{header-n124}{%
\subsubsection{反走样技术}\label{header-n124}}

Anti-Aliasing Technique

CG 总是会走样的。但我们能不能稍微挽救一下？

\hypertarget{header-n127}{%
\paragraph{采样}\label{header-n127}}

\begin{quote}
Sampling
\end{quote}

走样源自于采样。

采样就是把连续数据转变为离散信息的过程。这就是数据丢失的过程啊。

\begin{quote}
走样 \emph{zǒuyàng} \textbf{动}

失去了原来的样子。

\emph{这双鞋没穿几天就走样了 \textbar{} 贯彻会议精神不走样。}
\end{quote}

采样过程中会失真。失真过于明显，产生走样。

\hypertarget{header-n137}{%
\paragraph{Nyquist 采样定理}\label{header-n137}}

要想从采样信息中重建原始信号，则采样频率必须大于等于原始信号最大频率的两倍。

\hypertarget{header-n139}{%
\paragraph{反走样技术}\label{header-n139}}

用于减少或消除走样效果的技术。也称为抗锯齿算法。也称为 Anti-Aliasing
算法。也称为 AA。

\hypertarget{header-n141}{%
\paragraph{图形反走样}\label{header-n141}}

\hypertarget{header-n142}{%
\subparagraph{基础思路}\label{header-n142}}

把像素作为一个区域，按照区域进行采样。

按照我们栅格化图形的过程中，有的格子是部分落在原图形中的。我们按照占有的比率对其进行灰度级别上色，可以改善人眼的视觉体验。

\hypertarget{header-n145}{%
\subparagraph{操作}\label{header-n145}}

给定一个最大亮度值，代表完全被覆盖的情况下所对应的颜色。

而那些被部分覆盖的像素点的亮度值设定为（覆盖百分比 × 最大亮度值）。

\hypertarget{header-n148}{%
\subparagraph{问题}\label{header-n148}}

\begin{itemize}
\item
  无论像素距离图形有多远，相同的相交面积产生相同的亮度。也就是说离直线的距离这个因素并没有加权。因此还是有比较明显的锯齿效应。
\item
  直线上的相邻像素点可能产生较大的灰度差。
\end{itemize}

\hypertarget{header-n154}{%
\paragraph{FSAA}\label{header-n154}}

全屏反走样技术，Full-Scene Anti-Aliasing。

主要针对 3D 场景的绘制。通过密集的采样和滤波来减少锯齿效应。

FSAA 在渲染一个实际区域的时候（如 1024 ×
768）的时候，会事先计算出多倍大小的画面内容（如 4× 抗锯齿，会渲染出 2048
× 1536 的画面），通过密集的采样来进行全屏幕反走样操作。

\hypertarget{header-n158}{%
\paragraph{SS}\label{header-n158}}

Super Sampling，超级采样。

一个像素当作好几个像素来进行采样。那些「几个像素」就叫做「子像素」（Subpixels）。

渲染的时候场景放大渲染，但是以低分辨率进行显示。低分辨率下每一个像素都是多个像素加权平均的结果。

代价很高。真的很高。

\hypertarget{header-n163}{%
\paragraph{OGSS, RGSS, MSAA, Quincunx}\label{header-n163}}

SS 的几种实现。

OGSS：顺序栅格采样，按照 x、y 顺序进行采样。

RGSS：旋转栅格采样。

MSAA：多级采样技术，多边形内部无需超采样，因此 MSAA
只在边缘进行超采样，可以节约点时间。

Quincunx：五点梅花采样。每个点的颜色都跟自己周边的颜色有关，且分配有不同的权重。

\hypertarget{header-n169}{%
\paragraph{纹理反走样}\label{header-n169}}

\hypertarget{header-n170}{%
\paragraph{OpenGL 反走样技术}\label{header-n170}}

\hypertarget{header-n171}{%
\subsection{SE-302::Compilers}\label{header-n171}}

\(oh-my-compilers\)

今天要讲的内容是：Activation
Records。直译成了活动记录。另一个等价的大白话词语叫做 Frame（栈帧）。

这个 Activation Records 就跟 Function Call 十分相关。每一个 Function 被
call （或者说被 invoke）的时候，都会产生一个正在执行的 Function
的实例。我们把它叫做 Activation。

\hypertarget{header-n175}{%
\subsubsection{Activation}\label{header-n175}}

\hypertarget{header-n176}{%
\paragraph{Lifetime}\label{header-n176}}

Function 的实例，亦即
Activation，是有生命时间的。很自然；函数有执行就有返回。

\begin{quote}
类比：Variable 的 Lifetime。

变量当然也有 Lifetime；

一个开在栈上的局部变量在那个 Scope 退出的时候，

该 Variable 的生命就结束了。
\end{quote}

\hypertarget{header-n183}{%
\subsubsection{Memory Layout}\label{header-n183}}

内存如何布局？将内存空间分成一块块的。Code
放在最低内存地址位，其他空间放在高内存地址位。

上面提到，活在栈上的 Variable 的 Lifetime 就是由 Stack 顶指针 \%rsp
决定的。

那么对于函数的实例 Activation
呢？每一个「活动」的生命是如何被记录、存在的呢？

他们也活在栈上的。

以 Activation Record 的形式。

\hypertarget{header-n189}{%
\subsubsection{Activation Record}\label{header-n189}}

\hypertarget{header-n190}{%
\paragraph{简介}\label{header-n190}}

事实上 Activation Record 基本要包含这些东西：

\begin{itemize}
\item
  Callee Information
\end{itemize}

保存着被叫方的信息。

\begin{itemize}
\item
  Caller Information
\end{itemize}

保存着主叫方的信息。

因为在 Callee 生命结束的时候，控制流要回到 Caller
主叫指令的下一条继续执行。

\hypertarget{header-n201}{%
\subsubsection{高级语言}\label{header-n201}}

\begin{quote}
如果某一种语言同时允许：

a) 嵌套式函数定义；

b) 支持把函数作为返回值返回。

那么就把这门语言定义为「高阶语言」。

Tiger 支持 a) 但是不支持 b)；C 支持 b) 但是不支持 a)。

典型的高级语言如 ML 等。举例：
\end{quote}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{fun}\NormalTok{ f(x) =}
	\KeywordTok{let} \KeywordTok{fun}\NormalTok{ g(y) = x + y}
	\KeywordTok{in}\NormalTok{ g}
\KeywordTok{end}
\NormalTok{/* nested }\KeywordTok{function}\NormalTok{ decl */}

\KeywordTok{val}\NormalTok{ h = f(}\DecValTok{3}\NormalTok{)}
\KeywordTok{val}\NormalTok{ j = f(}\DecValTok{4}\NormalTok{)}
\NormalTok{/* h }\KeywordTok{and}\NormalTok{ j are functions! */}

\KeywordTok{val}\NormalTok{ z = h(}\DecValTok{5}\NormalTok{)}
\KeywordTok{val}\NormalTok{ w = j(}\DecValTok{7}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{header-n210}{%
\paragraph{Static Link}\label{header-n210}}

唯有支持 Static Link（静态链）的语言才能做到 Nested
Functions（嵌套式函数定义）。

在调用函数的时候被放在所有参数之前压栈的元素就是 Static Link 的位置。

\hypertarget{header-n213}{%
\subsubsection{Layout Design}\label{header-n213}}

编译阶段就需要确定 Frame Layout 的。

各种语言可以自己决定自己的实现；

但是为了让各种语言所编译出的机器码可以做到二进制兼容（Binary
Compatible），

大家都不约而同地采用了（几乎）同一种 Layout Design。

我们这里给出的那种 Layout Design（参见 P91 Figure 6-1）是很平凡的。

\hypertarget{header-n219}{%
\paragraph{Memory 越来越慢了。}\label{header-n219}}

其实不是的，是 SRAM 越来越快，Register 的访问速度比起 Memory
来越来越快了。

因此大家都不太愿意往内存丢东西了，总想着能往 Register 里放的就往
Register 里放。

比如说最新的 MIPS，连函数的返回值都不用栈了，直接丢进了 \%rax。

\hypertarget{header-n223}{%
\paragraph{Call-by-Value}\label{header-n223}}

常用的 C 就是传值式调用，所有的形式参数都只是在栈上分配的临时变量。

对形参的修改仅仅影响了栈，在 Scope
退出之后，就被抹杀掉了，完全影响不了实参。

\hypertarget{header-n226}{%
\paragraph{Call-by-Address}\label{header-n226}}

或者叫他 Call by Reference。

Fortran
就是这么办的，传给函数的参数并非被在栈上拷贝一份，而是直接把实参的内存地址压栈。Callee
直接拿着这个指针就能修改实参了。

这种情况下，考虑这种调用：

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ foo(}\DataTypeTok{int}\NormalTok{ &bar) \{}
\NormalTok{    bar = }\DecValTok{1}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{;}
\NormalTok{foo(i);}
\CommentTok{// now i = 1.}

\NormalTok{foo(i + }\DecValTok{1}\NormalTok{);}
\NormalTok{foo(}\DecValTok{42}\NormalTok{);}
\CommentTok{// ???}
\end{Highlighting}
\end{Shaded}

这里，因为 \texttt{i\ +\ 1} 不是左值，没办法传他的地址。

这种情况下，Fortran 会创建一个新的临时变量（在 Caller 的栈上），而非在
Callee 的栈上。

这就是奇妙的 Call-by-Reference。

如果我们要做 Reference call，那么这个变量肯定不能放寄存器了（你怎么去
\&register 呢？）

\hypertarget{header-n235}{%
\paragraph{Call-by-Restore / Copy-in Copy-out}\label{header-n235}}

Call by Value 和 Call by Reference 的混合体。

不仅把值在栈上拷了一份，连地址也都压了栈。Callee
写的时候直接改写这些值，在函数 Return
的时候按照这个地址把所有的左值都给写回去。

\ldots\ldots 这是干什么呢\ldots\ldots{}

\hypertarget{header-n239}{%
\paragraph{Myth}\label{header-n239}}

我们都是想尽量把参数往寄存器里放的。因为读写内存实在很费时费事。

但是考虑一下这种情况：

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ foo(}\DataTypeTok{int}\NormalTok{ a) \{}
    \CommentTok{/* actually foo does nothing. */}
\NormalTok{    a = a + }\DecValTok{1}\NormalTok{;}
\NormalTok{\};}
\DataTypeTok{void}\NormalTok{ bar(}\DataTypeTok{int}\NormalTok{ b) \{}
\NormalTok{    foo(}\DecValTok{42}\NormalTok{);}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

或许我们在调用 bar 的时候，b 可以被放在 Register 里（通常是 \%rdi）。

但是我们马上要调用 foo，这时候 \%rdi 又要被拿来存储 42
这个数。那咋办呢？

压栈？肯定不行，那就得读写内存了。

放到自己另外的寄存器里？但自己能决定拥有的寄存器是有限的。递归的时候肯定爆了。

放到 Callee-Saved
寄存器里，让子函数来帮我保存？那他一进去可不就是把那些寄存器给压栈么。那不还是有内存访问么。

\hypertarget{header-n248}{%
\paragraph{Variable Arguments}\label{header-n248}}

可变参数列表。

C/C++ 的经典语法：printf 就拥有一个可变长度的参数列表。

但是有一个特点：它至少有一个参数。

这一个关键参数（格式化字符串，或者类似的东西）可以控制我们怎么解读后面的参数列表。

C/C++ 又提供了一个保证：所有的参数都连续存放。

也就是说不会出现前一半儿参数放在这儿、后一半参数放在那儿、两边不挨着的情况。

主要是因为 C 的标准库中 \texttt{varargs} 的实现是基于内存连续寻址的。

所以变长参数列表就很难进入 Registers。至少那一串很难。

\hypertarget{header-n257}{%
\subsubsection{What does the Tiger say?}\label{header-n257}}

Tiger 里没有显式的 new。但是，Tiger 中的 Records 和 Arrays
都是放在堆（Heap）里的。

Tiger 中的 Record 和 Array 在作为参数传入的时候，传的都是指针。

\end{document}
