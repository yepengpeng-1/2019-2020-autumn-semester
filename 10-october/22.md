# Oct 22 Tue

## SE-302::Compilers

继续说 Activation Records。

上节课说的，我们通过一个叫做 "static link" 的东西来实现跨 Scope 访问。跨多少层静态嵌套层，就需要多少次寻址。

这个 static link 需要被传递。如何？我们默认它是每个函数的第一个参数。

### static link

实际上只是一个访问「上一层函数」的 Frame（栈底）的指针。

但实际上我们怎么使用？

#### Usage

在发现一个当前 Scope 里找不到的符号的时候，我们就从 static link 着手往上一层的 Frame 寻找，找我们需要的那个符号；如果这一层还是没有，就继续通过它的「首位隐形参数」寻找继上层的 Frame。

所有上面这些操作都是需要在编译期生成实际指令的。

####P.S.

一个会被自己的孩子 Scope 访问的局部变量是必须进栈的。

### display

static link 访存次数太多了。有没有好点的办法？

display 学名是嵌套层次显示表。本质上就是一个全局数组 `array`。`array[i]` 是一根指针，指向的是最近一次进入的静态嵌套深度为 `i` 的栈位置。

####Mutable

display 是一个动态改变的表。随着调用过程的深入浅出，display 会随时改变。

#### Quick

在我们已经知道嵌套层次深度的时候，不再需要像是 static link 一样的多次奔波。只需要做一次数组的访问就可以，无论嵌套层次深度差有多少。

### λ Lifting

Lambda Lifting。这是个什么主意呢？

#### Idea

对于 `g` 调用一个函数 `f` 时，把函数 `f`（及其内部嵌套的函数）使用到的 `g` 中的变量都作为额外的参数传给 `f` 。

反正要用到哪些外部变量，我们都（在编译期）知道了。

### What about a Tiger?

本书采用了 static link 的实现方法。

### Frame

栈帧：Tiger 是怎么实现的？

#### Incompatible

比较大的问题是：不同的环境存在不同的栈帧布局。这也很正常：64 位跟 32 位生成代码的栈帧肯定具有不同的布局：指针长度都不同。

为了实现编译器的可移植性，我们最好不要直接写 Machine Dependent 的代码到编译器中，否则要支持一个新的平台，代价会太大。

#### Abstract Methods

解决方法就是：使用抽象方法来实现栈帧，隐藏底部具体（机器相关）实现。

这样对每一种 arch，只需要实现一遍 Abstract Method 就能完成移植了，而不需要改动 Compilers 的逻辑部分。

#### Frame Structure

Abstract Methods 在 `<frame.h>` 中被定义。

```c++
/* frame.h */
typedef struct F_frame_ *F_frame ;
F_frame F_newFrame(Temp_label name, U_boolList formals);
```

一个关键信息是 Formal Parameters（形式参数）和在栈上分配的临时变量。

####Escape

那么 `U_boolList` 是个啥？这是一串儿 Bool 标记，对应到每个形参；

它指定的是 Escape 与否。

如果 Escape 为真，则此参数不可被放入寄存器，而必须被放在栈上。

因为他要被用于后续的 escaping static link。

否则如果 Escape 为假，则无需在意其是否被放入寄存器或是栈上。

#####Swift `@escaping`

```swift
func foo(strList: @escaping String[]) {
    
}
```

Swift 的 `@escaping` Annotation 就表达了这个意思。