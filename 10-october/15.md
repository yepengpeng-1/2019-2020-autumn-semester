# Oct 15 Tue

## SE-302::Compilers

今天我们要讲的是 Type Checking。

回忆一下我们上回讲的 Symbol Table。这个过程会生成两张符号表：venv (variable environment) 和 tenv (type environment)。

Type Checking 要做的就是：检查表达式中出现的操作符能否结合，并计算出整个表达式的类型。（为了进行下一步计算。）

### Tiger 里的类型

* `Ty_record`
* `Ty_nil`

* `Ty_int`

整型！

* `Ty_string`

字符串！

* `Ty_array`

数组！（P.S. Array 可能会装填着不同类型的元素，因此还需要一个额外参数来指定 Element Type。）

* `Ty_name`

Name 就是 Symbol 的名字。

* `Ty_void`

大概只会在函数返回值里用。

### Type Checking Expressions

Type Checking 要做的事情：

* 扫描一遍代码，得到一个 Abstract Syntax Tree。

Type Checking 用黑话来说，就叫 Translation。所以下面的缩写都是从他来的。

#### 检查表达式

```c++
struct expty transExp(S_table venv, S_table tenv, A_exp a) {
    switch(a->kind) {
        case A_opExp:
            if (/* 合法 */) {
                // 合法的时候，构造出一个类型代表表达式返回的类型
                return expTy(NULL, Ty_Int());
            } else {
                // 不合法的时候，返回错误值
            }
            break;
        case A_letExp:
            // let
            //  ... decs
            // in
            //  ... body
            // end
            
            /* let 操作符需要做的事情是
               创建一个新的 environment，然后用它来
               递归地去遍历 body 内内容。
            */
            break;
        case /* other ops */:
            break;
    }
}
```

#### 检查类型

Tiger Language 里面，有三种不同的 Variable：

* Simple Variable

简单变量就是个符号。里面又包括 varEntry（一般变量）和 funEntry（一般函数）。

* Field Variable

实参列表里的变量。

* Subscript Variable

Subscript 用的 Variable，形如 `a.i` 或是 `a[i]` 的变量 `i` 就叫做 subscript variable。

```c++
struct expty transVar(S_table venv, S_table tenv, A_var a) {
    switch (v->kind) {
        case A_SimpleVar : {
            // 简单变量，先从符号表里找这个
            auto x = S_look(venv, v->u.simple);
            if (x && x->kind == E_varEntry) {
                // 如果我们拿到的是个名字类型，
                // 比如是 let type := int 这种一层包装的类型，
                // 就追根究底找出最基本的类型。
                // 所以有那么一句 actual_ty。
                return ExpTy(NULL, actual_ty(x->u.var.ty));
            } else {
                EM_Error("哈哈哈哈哈哈哈哈错误消息\n");
            }
        }
    }
}
```

#### 检查声明

##### 变量声明

处理一个无类型约束的变量声明：

```Tiger
var x := exp
```

很简单，因为我们了解赋值操作右边 `exp` 的唯一类型，把它当作 `x` 的类型就可以了。

但也有这种写法：

```Tiger
var x: Type := exp
```

同时给出了可用于类型推断的 `exp` 和声明好的 `Type`。这就是说我们需要考虑推断出来的隐含 Type 跟显式说明的 Type 是否兼容。

#####Ms.Nil

Ty_Nil 是空指针类型，它可同任何类型兼容。她的实例 Nil 值为空，用于初始化各种类型的对象。

#####函数声明

函数的声明方法……

```tiger
function f(a: ta, b: tb): rt = body
```

我们用到 `transDec` 函数。

```c++
void transDec(S_table venv, S_table tenv, A_dec d) {
    switch (d->kind) {
        // ...
        case A_functionDec: {
            /* 啊，是个函数声明！ */
            A_fundec f = d->u.function->head;
            
            Ty_ty resultTy = S_look(tenv, f->result);
            // 确认函数的返回值。
            
            Ty_tyList formalTys = makeFormalTyList(tenv, f->params);
            // 构造出形参类型列表。我们不关心他们的名字。
            
            // 到此为止我们有足够的信息来构造这个 funEntry 并放入值环境中 `venv` 了。
            // 注意，到此为止我们还没有开始分析 body 的内容，
            // 也就是说在 body 被分析之前，我们已经把函数 funEntry 放到环境里了。
            // 这也就是为什么递归可以被实现。
        }
    }
}
```

