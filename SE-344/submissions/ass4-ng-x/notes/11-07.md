# Nov 7 Thu

## SE-344::CG

### 章节三：建模与动画

今天要讲的内容：

*   细化/Tessellation
*   并化/Consolidation
*   条化/Stripification
*   简化/Simplification
*   细节层次模型/LOD

#### 高效的多边形化（细化）

所谓的 *Efficient* Tessellation。根据细化施加对象来分类，主要分为以下三类：

1.  将一系列离散点给多边形化。（本来一系列点之间是离散而不连续的。本质上类似于从取样点中重建出几何结构。）
2.  多边形细化。（以茶壶集合为例，可以使得不连续的多边形趋于光滑。）这里有一些我们为何要进行多边形细化的原因：

>   P.S. 大部分的 API 及硬件都针对三角形进行了特殊优化。
>
>   P.P.S. 大部分绘制器只能够处理凸多边形。那假如我们有了一个凹多边形，就不得不通过细化将其拆分为凸多边形片再进行绘制。
>
>   P.P.P.S. 为了实现光滑的光照计算，一般会先进行多边形细化之後再计算光照。

3.  曲面多边形化。

>   这有什么意义呢？曲面本身光顺的，多边形化了不就离散了？
>
>   主要是为了方便绘制…曲面是不好画的。（而细化之後的四边形／三角形就方便了。）

把离散点集合／复杂多边形／曲面转换为多个三角形的过程称为三角形化（Triangulation）。

也称之为三角剖分。

逐个来看。

##### 离散点集合的三角形化

######要求

把曲面剖开成三角形之後，每块碎片都是曲边三角形；

任意两个三角形**最多**只有一条公共边。不可以重叠。

###### 欧拉示性公式

$e = p - l + n$

对于一个确定曲面的所有剖分，$e$ 是一个常数。

$p$、$l$、$n$ 分别为点、边、和面的个数。

###### 洞眼

示性数 $e = 2 - 2g$

$g$ 是曲面上「洞眼」的个数。

###### 法一：Delaunay 三角剖分

【定义一】某一条边具有两个端点 $a$ $b$；存在过 $a$、$b$ 两个点的圆不包含任何其他点；则称此边为 Delaunay 边。

给人的直观感觉就是：按照 Delaunay 边来剖分的话，「感觉」剖线会较小，分割较匀称。（完全感觉）

【定义二】只通过 Delaunay 边进行的剖分称为 Delaunay 三角剖分。

【准则】最大化最小角；在点集合可能形成的三角剖分之中，Delaunay 三角剖分所形成的三角形的最小角最大。

从这个意义上讲，Delaunay三角网是「最接近于规则化的」的三角网。具体的说是指在两个相邻的三角形构成凸四边形的对角线，在相互交换后，六个内角的最小角不再增大。

*   最接近：以最近的三点形成三角形，且各线段（三角形的边）皆不相交。
*   唯一性：不论从区域何处开始构建，最终都将得到一致的结果。
*   最优性：任意两个相邻三角形形成的凸四边形的对角线如果可以互换的话，那么两个三角形六个内角中最小的角度不会变大。
*   最规则：如果将三角网中的每个三角形的最小角进行升序排列，则Delaunay三角网的排列得到的数值最大。
*   区域性：新增、删除、移动某一个顶点时只会影响临近的三角形。
*   具有凸多边形的外壳：三角网最外层的边界形成一个凸多边形的外壳（Shell）。

######法二：Lawson 局部优化算法

~~开便利店的也来做 CG 了~~

所谓 Local Optimization Procedure。做法就是在 Delaunay 剖分时，每产生一次点变换就进行一次局部检查： 

将两个具有共同边的三角形合成一个四边形；以最大空圆准则来检查，看任取三个点确定的圆是否包含了第四个点。如果检测发现落在其外，就交换对角线以进行修正。

缺点：因为每次插入／删除点操作都必须进行操作。

另外，在存在空洞时，Lawson 算法会出错。 

###### 实际情况

现实世界总是纷繁复杂的。没有一种公理可以进行「绝对正确」的剖分。

只有适合要进行操作的剖分。

##### 多边形的细化算法

###### 法一：将三位多边形投影成二维图形来处理

先对多边形进行面积测试，或是通过法向量的算法来决定；

决定丢弃掉 $x$、$y$、或 $z$ 中的某一个坐标，再做类似于上面的方法。

问题也很明显：投影会丢失信息。在自交错比较明显的时候无法很好处理。

###### 法二：三角形细化

检查多边形中任意两顶点之间的线段，将多边形分成了两个部分；再分别对每个方面进行这样的操作，直到只有三角形。

复杂度：$O(n^3)$。痛苦。

###### 法三：耳状剪切

Ear Clipping 法的思路是：每次总是挑出一个「尖角」来切掉，确保切去的那一部分一定是一个三角形。

另外，每次都选角度最小的耳状物来切分作为最优解。

复杂度：$O(n^2)$。略好。

```
简单多边形的耳朵，是指由连续顶点V0,V1和V2组成的内部不包含其他任意顶点的三角形。在计算机几何术语中，v0与V2之间的连线 称之为多边形的对角线，点V1称之为耳尖。虽然你可以将耳尖放到三角形的任意一个顶点上，但是我们认为三角形包含一个耳尖。一个由四个顶点（或者更多）组成的多变形至少有两个不重叠的耳尖。这个特性提供了一个通过递归来解决三角化分割的方法。针对由N个定点组成的多边形，找到其耳尖，移除唯一耳尖上的顶点，此时剩余顶点组成了一个n-1个顶点的简单多边形。我们重复这个操作知道剩余三个顶点。这样的话会产生一个复杂度为O(N3)的算法

随着一些细节改进，耳朵消除可以在O （ N2）的时间来完成。第一步是将多边形使用双向链表存储，这样可以快速的移除耳朵。列表的构建复杂度是O（n），第二部是遍历顶点寻找耳朵。对于每一个顶点Vi和围绕该顶点的三角形<Vi-1,Vi，Vi+1>，(总长度为N，所以Vn=V0，兵器V-1=Vn-1),测试其他顶点是否在当前三角形中，如果有一个顶点在三角形里面，则不是耳朵，只有都不在的情况，才算是找到一个耳朵。具体实现的时候我们可以考虑以下因素让这个算法更为高效。当发现有一个点在三角形里面的时候便可以开始放弃当前测试。一个凹拐角其两边的夹角大于180，而一个凸拐角两边夹角小于180。存储多边形的数据结构使用四个链表，具体使用数组而不是标准的动态需要分配合释放存储器的链表。多边形的顶点存储在在一个循环链表中，凹顶点和凸顶点存储在线型表中，耳尖存储在一个循环列表中。

一旦凸顶点和耳朵的链表构建成功，每次遍历都会移除一个耳朵。假设当前Vi是个耳朵并且被移除掉，那么边结构的相邻点Vi-1,Vi+1则会发生变化，如果相邻点是凸顶点，那么依旧保持凸点，如果相邻点是个耳朵，那么当Vi被移除后则不一定能保持耳朵的状态，如果相邻点是个凹点，那么他则有可能变为一个凸点甚至是耳朵。因此当移除顶点Vi后，如果相邻点是凸点，则必须遍历相关顶点，通过遍历查看是否包含其他点，来测试它是否是一个耳朵。我们有n个耳朵，每一次更新都会触发一个耳朵检测，每次过程中更新O（n），所以移除进程的复杂度是O(n2)。
```

#####多轮廓多边形细化

首先，得把多轮廓多边形转换成单轮廓。

所谓多轮廓，本质上还是因为存在内孔洞。

我们只需要首先通过一个「连接到内孔洞」的分割线将其降格为外轮廓即可。

##### 曲面的细化算法

###### 法一：均匀细化

Uniform Tesselation

在 $u$、$v$ 方向上均匀地取间隔来实现。

问题在于：不够快。等距离取样太费时间；而且对于曲面形状的保留不好；有些很平缓的地方取样点太多，有的变化急促的地方又没有足够的取样。

###### 法二：差分细化：向前

将 Bèzier 曲线写成多项式形式，在向前差分的过程中计算间距均匀为 $t$ 的多项式。

###### 法三：自适应细化

均匀细化的问题就在于平缓的地方和陡峭的地方都要采用同样精度的采样；但他们并不是都需要。

有一些陡峭的地方可能需要更多的面片来逼近；有的平缓的地方可能需要更少。

有没有一个算法可以自我适应，自己决定采用多高的精度来采样呢？

有的。主要思路是「判断三角形及其边是否已经被足够地细分了」。

通过判断三角形和实际曲面、三角形边和实际曲线的「差异大小」来判断「细分的充分性」。

对于一个三角形来说，有以下四种情况：

*   三角形的三条边的细分都不充分。（太粗略了，直接取三条边上的中点，拆成四个三角形吧）
*   有两条边细分不充分。（用不充分的两条边的中点加上任取一个顶点，拆分成三个三角形）
*   有一条边细分不充分。（用不充分边的中点加上该边对应的顶点连起来，拆分成两个三角形）
*   三条边都充分细分了，只是三角形面片本身还没细分充分。（直接用三角形重心和三个顶点拆分成四个三角形）

留意：不要太苛刻了。如果你的要求太苛刻，可能会出现无限细分的死循环。要给出一个合理的退出条件。

###### 法四：分数细化

Fractional Tessellation。自适应细化的变体。

#####一些优化

*   首先判断物体的局部邻域是否在我们可见的视锥内。
*   判断其的可显示面是否朝向我们。
*   判断其是否在屏幕空间内占据有较大的区域。（如果只占有很少的几个像素，就不进行细分）
*   判断其是否靠近当前视点的轮廓部位。（如果在，就应该使用相对更细节的划分）
*   判断其是否收到大量镜面光的照射。（如然，则应采用极为细节的划分。因为在高光下很容易看出三角形，一定要尽力避免这种情况。）

#####迷思

######着色问题

为了方便渲染和着色，我们一般会把四边形分割为三角形。

考虑到三角形有比较方便的「重心法」来实现颜色双线性插值，拆分为三角形似乎是最好的办法。

然而问题来了：三角剖分的不同选择会明显地产生不一样的着色效果。

假如我们将两个颜色或亮度差异很大的两个点连接在一起作为剖分，就会产生一条很明显的亮线。

Too bad。

这种顶点被称为「T 形顶点」，不合适的分割会造成诡异的着色分块。

因此在此时，三角剖分方案又和我们需求的着色样式有关了。

######纹理问题

跟上面的着色同样，不同的划分方法会严重影响贴图实际效果。

######边缘裂缝

为什么会产生裂缝呢？

有的时候，是绘制误差带来的极细小的裂缝；有的时候，可能是舍入误差导致的模型破裂。

#### 合并

Consolidation. Show me how?

细化完成了。顶点和边都找出来了；但是是散乱的。我们还需要搜索并调整细化处理得到的多边形的连接关系；此过程称之为「合并」。

原有数据的连接和融合；新数据的衍生（法矢量的生成和规范）

##### 基本流程

*   得到所有多边形的边、面结构，并对其进行排序。
*   找到相连的多边形组；确定体特性，寻找其边界边。
*   对每组边都进行必要的反转来保证一致性。
*   确定网格内部方向；如有需要，对面片进行翻转。
*   找出折叠边界。
*   生成多边形网格 Mesh（网）。

Mesh 中所有的点都只存储一次；通过点之间的拓扑关系来决定图形。

#### 条化

Stripification.

将三角形网格转化为多边形条带。

##### Triangle Strips

三角形条带…OpenGL 已经提供了画条带的方法了。

准确点说，是 FreeGLUT 提供了。

因此如果我们能做到条带化，就能相当简单地实现模型的渲染了。