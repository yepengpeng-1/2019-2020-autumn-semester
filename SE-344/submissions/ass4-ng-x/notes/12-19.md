# Dec 19 Thu

## SE-344::CG

### 真实

什么是真实？什么可以怀疑？

你不可以怀疑你在怀疑这件事情本身。——XYB & DKE

>   DKE := 笛卡尔

为了使得我们的渲染结果更为真实…我们引入了光和反射。这两件事能使得我们的结果显得相当真实。

---

### 反射

#### BRDF 反射模型

什么是 BRDF 啊？

>   **雙向反射分布函數**（**bidirectional reflectance distribution function**、**BRDF**）。

BRDF 是一個定義[光線](https://zh.wikipedia.org/wiki/光)在不透明表反射的四次元[函數](https://zh.wikipedia.org/wiki/函數)，基本式為：${\displaystyle {f_{r}(\omega _{i},\omega _{r})\ }}$，在這裡 ${\displaystyle \omega _{i}\ }$ 是指[光線](https://zh.wikipedia.org/wiki/光線)的反方向，另外  ${\displaystyle \omega _{r}\ }$ 是指光線[反射](https://zh.wikipedia.org/wiki/反射)的方向，除此之外，還有一個 ${\displaystyle \mathbf {n} }$ 代表[法線](https://zh.wikipedia.org/wiki/法线)，這個值的意義是在 ${\displaystyle \omega _{\text{r}}}$方向的反射光線的 [輻射率](https://zh.wikipedia.org/wiki/辐射率) 和同一點上 從 ${\displaystyle \omega _{\text{i}}}$ 方向射入的光線的[輻射率](https://zh.wikipedia.org/wiki/辐射率)的比值。每一個 $\omega $ 方向可以被[參數化](https://zh.wikipedia.org/w/index.php?title=参数化&action=edit&redlink=1)　為 [方位角](https://zh.wikipedia.org/wiki/方位角) $\phi$ 和 [天頂角](https://zh.wikipedia.org/wiki/天頂角)  $\theta$。因此BRDF是一個四維函數。 BRDF的單位是 sr^−1^, 其中 (sr) 是 [球面度](https://zh.wikipedia.org/wiki/球面度)的單位.

假如我们不考虑「实际上的光线可能来自多个方向」，那么我们就可以去掉这个二维积分，仅考虑一个方向上的入射光。这样 BRDF 的方程就简化为一般的反射方向，加上一个四次参数。

确定了这个参数，就知道了 BRDF 参数。

---

##### 测量

我们可以通过简单测量的办法来确认不同材料表面的 BRDF 参数。

##### 理论模型

通过物理计算来确定这四个参数…（逃

主要的纠结点有：镜面叶的方向、汇聚系数、考虑菲涅耳现象与否。

##### 基于图像

通过我们真实世界拍摄的图像来「学习」参数…

##### 做伸手党

抄现成的参数（

### 折射

考虑一下：在我们的光经过一个非全不透明的物体的时候，我们的光不仅会按照上面的规律反射，还可能会按照折射定律 ($m sin\alpha = n sin\beta$)产生折射…

### 光影

这里的部分都已经是非常细枝末节的部分了。

阴影是个很要紧的事情：在出现阴影的时候，我们就能更直观地了解到物体在空间中的位置关系，也是增强真实感的一点细节吧。

#### 反射

反射应该是最容易实现的了：直接对着世界坐标系做变换，然后直接对着平面做一个反射就好了。

#### 预防反射失真

过于「完美」的反射会适得其反：倒影怎么会跟原像一模一样呢？难道没有反射亮度衰减和微小的形变吗？

所以我们对着平面增加了一个 Mask：这个遮罩会阻碍（部分）反射，模拟出影影绰绰的感觉。

#### 硬阴影 & 软阴影

一个有一定宽度的光源和有一定宽度的遮挡物，一定存在一个类似于「单缝干涉」的亮度波形样。

我们称：从该定长宽度光源的任何一处发出的光都无法到达的位置称为「遮挡物」的本影区，这部分就称为硬阴影。而那些只有一些部分发出的光能到达，有一些部分被遮挡的范围称为「软阴影」。总是可达的位置则不称为阴影。

### 纹理

为了用最最低的成本来实现某种大量规律性的、背景性的画面效果…

…就直接贴图好了。效果也差不多嘛（×）

材质细节、光照细节、几何细节全部都可以直接贴图解决了。

但是，要贴得好看、贴得漂亮，我们还是需要费一番功夫的。

#### 原理

将纹理模式映射到物体模型表面，以便模拟物体表面材质细节、光照细节和几何细节的这个过程就称为「纹理映射」（Texture Mapping）。

>   纹理并不一定是二维的。待会可以看到也存在一维和三维的纹理。

但我们先以（最常用的）二维纹理空间为例。

这种纹理一般定义在单位正方形域中。

#### 描述

纹理可以使用函数来描述：类似于 $g(s, t)$ 这样的双参数函数。

当然，一张位图也可以作为纹理使用。

#### 映射

我们现在有了纹理表示了；该怎么映射到物体上面呢？

*   纹理扫描

    直接将纹理模式「糊」到物体表面，然后交给後面的干活。

    但是这样耗费高，而且可能在后面进行投影变换後，我们的纹理就变形了。

*   像素次序扫描

    先将投影平面的像素区域映射到物体表面（做逆向投影变换），再对这些像素进行扫描。

    这就可以保证我们的纹理不会再最终结果中产生变形，且能保证最终的纹理结果均匀。

    这个方法，好！我们要多用啊。

---

重大问题：你这个，「逆向投影变换」是咋做的啊？

我们还得先看投影函数是怎么做的。

$P(x, y, z)$ => $(s, t)$。但这怎么才能反向确定呢？

*   方法一：在建模的时候就提供一个不参与投影的「贴图坐标」，这样就能保留一一对应信息。
    *   问题：消耗太大。我们用不起。
*   方法二：结合简单片元形状反推。
    *   这种问题就在于不能自由调整贴图的方向（只能沿着 $(u, v)$ 的方向来），而且计算量大。
*   方法三：两步法。
    *   基本思想：先把纹理给贴到简单的 3D 表面上（类似于平面、球面、圆柱面、立方体面等等），称之为中介面。中介面应该完全在目的物体外围。
    *   这个计算相对方便（因为物体简单啊）。这个过程称为 S Mapping。
    *   然后，再把纹理从中介面上再贴到实际的物体上，称为 O Mapping。