# Nov 7, Thu

超长调休之後第一次上课。四天没上课了。

其中前两天在南京挥霍无度，後两天在学校连肝两 Lab。

生命垂危。

## SE-227::CSE

###Before or After

在分拆在不同线程的程序中，无论按照何种顺序进行运行，都可以正常运行并给出结果，所谓 Before / After。

### Transaction

这里的 Transaction 不再仅仅是本地数据库中的处理方式了；希望这可以被用来处理全球所有类型的分布式（带有竞争, Race）的处理问题。包括我们的 Network File System。包括黄肤浅的 Lab 3 & 4。

## SE-344::CG

### 章节三：建模与动画

今天要讲的内容：

*   细化/Tessellation
*   并化/Consolidation
*   条化/Stripification
*   简化/Simplification
*   细节层次模型/LOD

#### 高效的多边形化（细化）

所谓的 *Efficient* Tessellation。根据细化施加对象来分类，主要分为以下三类：

1.  将一系列离散点给多边形化。（本来一系列点之间是离散而不连续的。本质上类似于从取样点中重建出几何结构。）
2.  多边形细化。（以茶壶集合为例，可以使得不连续的多边形趋于光滑。）这里有一些我们为何要进行多边形细化的原因：

>   P.S. 大部分的 API 及硬件都针对三角形进行了特殊优化。
>
>   P.P.S. 大部分绘制器只能够处理凸多边形。那假如我们有了一个凹多边形，就不得不通过细化将其拆分为凸多边形片再进行绘制。
>
>   P.P.P.S. 为了实现光滑的光照计算，一般会先进行多边形细化之後再计算光照。

3.  曲面多边形化。

>   这有什么意义呢？曲面本身光顺的，多边形化了不就离散了？
>
>   主要是为了方便绘制…曲面是不好画的。（而细化之後的四边形／三角形就方便了。）

把离散点集合／复杂多边形／曲面转换为多个三角形的过程称为三角形化（Triangulation）。

也称之为三角剖分。

逐个来看。

##### 离散点集合的三角形化

######要求

把曲面剖开成三角形之後，每块碎片都是曲边三角形；

任意两个三角形**最多**只有一条公共边。不可以重叠。

###### 欧拉示性公式

$e = p - l + n$

对于一个确定曲面的所有剖分，$e$ 是一个常数。

$p$、$l$、$n$ 分别为点、边、和面的个数。

###### 洞眼

示性数 $e = 2 - 2g$

$g$ 是曲面上「洞眼」的个数。

###### 法一：Delaunay 三角剖分

【定义一】某一条边具有两个端点 $a$ $b$；存在过 $a$、$b$ 两个点的圆不包含任何其他点；则称此边为 Delaunay 边。

给人的直观感觉就是：按照 Delaunay 边来剖分的话，「感觉」剖线会较小，分割较匀称。（完全感觉）

【定义二】只通过 Delaunay 边进行的剖分称为 Delaunay 三角剖分。

【准则】最大化最小角；在点集合可能形成的三角剖分之中，Delaunay 三角剖分所形成的三角形的最小角最大。

从这个意义上讲，Delaunay三角网是「最接近于规则化的」的三角网。具体的说是指在两个相邻的三角形构成凸四边形的对角线，在相互交换后，六个内角的最小角不再增大。

*   最接近：以最近的三点形成三角形，且各线段（三角形的边）皆不相交。
*   唯一性：不论从区域何处开始构建，最终都将得到一致的结果。
*   最优性：任意两个相邻三角形形成的凸四边形的对角线如果可以互换的话，那么两个三角形六个内角中最小的角度不会变大。
*   最规则：如果将三角网中的每个三角形的最小角进行升序排列，则Delaunay三角网的排列得到的数值最大。
*   区域性：新增、删除、移动某一个顶点时只会影响临近的三角形。
*   具有凸多边形的外壳：三角网最外层的边界形成一个凸多边形的外壳（Shell）。

######法二：Lawson 局部优化算法

~~开便利店的也来做 CG 了~~

所谓 Local Optimization Procedure。做法就是在 Delaunay 剖分时，每产生一次点变换就进行一次局部检查： 

将两个具有共同边的三角形合成一个四边形；以最大空圆准则来检查，看任取三个点确定的圆是否包含了第四个点。如果检测发现落在其外，就交换对角线以进行修正。

缺点：因为每次插入／删除点操作都必须进行操作。

另外，在存在空洞时，Lawson 算法会出错。 

###### 实际情况

现实世界总是纷繁复杂的。没有一种公理可以进行「绝对正确」的剖分。

只有适合要进行操作的剖分。

##### 多边形的细化算法

###### 法一：将三位多边形投影成二维图形来处理

先对多边形进行面积测试，或是通过法向量的算法来决定；

决定丢弃掉 $x$、$y$、或 $z$ 中的某一个坐标，再做类似于上面的方法。

问题也很明显：投影会丢失信息。在自交错比较明显的时候无法很好处理。

###### 法二：三角形细化

检查多边形中任意两顶点之间的线段，将多边形分成了两个部分；再分别对每个方面进行这样的操作，直到只有三角形。

复杂度：$O(n^3)$。痛苦。

###### 法三：耳状剪切

Ear Clipping 法的思路是：每次总是挑出一个「尖角」来切掉，确保切去的那一部分一定是一个三角形。

另外，每次都选角度最小的耳状物来切分作为最优解。

复杂度：$O(n^2)$。略好。

```
简单多边形的耳朵，是指由连续顶点V0,V1和V2组成的内部不包含其他任意顶点的三角形。在计算机几何术语中，v0与V2之间的连线 称之为多边形的对角线，点V1称之为耳尖。虽然你可以将耳尖放到三角形的任意一个顶点上，但是我们认为三角形包含一个耳尖。一个由四个顶点（或者更多）组成的多变形至少有两个不重叠的耳尖。这个特性提供了一个通过递归来解决三角化分割的方法。针对由N个定点组成的多边形，找到其耳尖，移除唯一耳尖上的顶点，此时剩余顶点组成了一个n-1个顶点的简单多边形。我们重复这个操作知道剩余三个顶点。这样的话会产生一个复杂度为O(N3)的算法

随着一些细节改进，耳朵消除可以在O （ N2）的时间来完成。第一步是将多边形使用双向链表存储，这样可以快速的移除耳朵。列表的构建复杂度是O（n），第二部是遍历顶点寻找耳朵。对于每一个顶点Vi和围绕该顶点的三角形<Vi-1,Vi，Vi+1>，(总长度为N，所以Vn=V0，兵器V-1=Vn-1),测试其他顶点是否在当前三角形中，如果有一个顶点在三角形里面，则不是耳朵，只有都不在的情况，才算是找到一个耳朵。具体实现的时候我们可以考虑以下因素让这个算法更为高效。当发现有一个点在三角形里面的时候便可以开始放弃当前测试。一个凹拐角其两边的夹角大于180，而一个凸拐角两边夹角小于180。存储多边形的数据结构使用四个链表，具体使用数组而不是标准的动态需要分配合释放存储器的链表。多边形的顶点存储在在一个循环链表中，凹顶点和凸顶点存储在线型表中，耳尖存储在一个循环列表中。

一旦凸顶点和耳朵的链表构建成功，每次遍历都会移除一个耳朵。假设当前Vi是个耳朵并且被移除掉，那么边结构的相邻点Vi-1,Vi+1则会发生变化，如果相邻点是凸顶点，那么依旧保持凸点，如果相邻点是个耳朵，那么当Vi被移除后则不一定能保持耳朵的状态，如果相邻点是个凹点，那么他则有可能变为一个凸点甚至是耳朵。因此当移除顶点Vi后，如果相邻点是凸点，则必须遍历相关顶点，通过遍历查看是否包含其他点，来测试它是否是一个耳朵。我们有n个耳朵，每一次更新都会触发一个耳朵检测，每次过程中更新O（n），所以移除进程的复杂度是O(n2)。
```

#####多轮廓多边形细化

首先，得把多轮廓多边形转换成单轮廓。

所谓多轮廓，本质上还是因为存在内孔洞。

我们只需要首先通过一个「连接到内孔洞」的分割线将其降格为外轮廓即可。

##### 曲面的细化算法

###### 法一：均匀细化

Uniform Tesselation

在 $u$、$v$ 方向上均匀地取间隔来实现。

问题在于：不够快。等距离取样太费时间；而且对于曲面形状的保留不好；有些很平缓的地方取样点太多，有的变化急促的地方又没有足够的取样。

###### 法二：差分细化：向前

将 Bèzier 曲线写成多项式形式，在向前差分的过程中计算间距均匀为 $t$ 的多项式。

###### 法三：自适应细化

均匀细化的问题就在于平缓的地方和陡峭的地方都要采用同样精度的采样；但他们并不是都需要。

有一些陡峭的地方可能需要更多的面片来逼近；有的平缓的地方可能需要更少。

有没有一个算法可以自我适应，自己决定采用多高的精度来采样呢？

有的。主要思路是「判断三角形及其边是否已经被足够地细分了」。

通过判断三角形和实际曲面、三角形边和实际曲线的「差异大小」来判断「细分的充分性」。

对于一个三角形来说，有以下四种情况：

*   三角形的三条边的细分都不充分。（太粗略了，直接取三条边上的中点，拆成四个三角形吧）
*   有两条边细分不充分。（用不充分的两条边的中点加上任取一个顶点，拆分成三个三角形）
*   有一条边细分不充分。（用不充分边的中点加上该边对应的顶点连起来，拆分成两个三角形）
*   三条边都充分细分了，只是三角形面片本身还没细分充分。（直接用三角形重心和三个顶点拆分成四个三角形）

留意：不要太苛刻了。如果你的要求太苛刻，可能会出现无限细分的死循环。要给出一个合理的退出条件。

###### 法四：分数细化

Fractional Tessellation。自适应细化的变体。

#####一些优化

*   首先判断物体的局部邻域是否在我们可见的视锥内。
*   判断其的可显示面是否朝向我们。
*   判断其是否在屏幕空间内占据有较大的区域。（如果只占有很少的几个像素，就不进行细分）
*   判断其是否靠近当前视点的轮廓部位。（如果在，就应该使用相对更细节的划分）
*   判断其是否收到大量镜面光的照射。（如然，则应采用极为细节的划分。因为在高光下很容易看出三角形，一定要尽力避免这种情况。）

#####迷思

######着色问题

为了方便渲染和着色，我们一般会把四边形分割为三角形。

考虑到三角形有比较方便的「重心法」来实现颜色双线性插值，拆分为三角形似乎是最好的办法。

然而问题来了：三角剖分的不同选择会明显地产生不一样的着色效果。

假如我们将两个颜色或亮度差异很大的两个点连接在一起作为剖分，就会产生一条很明显的亮线。

Too bad。

这种顶点被称为「T 形顶点」，不合适的分割会造成诡异的着色分块。

因此在此时，三角剖分方案又和我们需求的着色样式有关了。

######纹理问题

跟上面的着色同样，不同的划分方法会严重影响贴图实际效果。

######边缘裂缝

为什么会产生裂缝呢？

有的时候，是绘制误差带来的极细小的裂缝；有的时候，可能是舍入误差导致的模型破裂。

#### 合并

Consolidation. Show me how?

细化完成了。顶点和边都找出来了；但是是散乱的。我们还需要搜索并调整细化处理得到的多边形的连接关系；此过程称之为「合并」。

原有数据的连接和融合；新数据的衍生（法矢量的生成和规范）

##### 基本流程

*   得到所有多边形的边、面结构，并对其进行排序。
*   找到相连的多边形组；确定体特性，寻找其边界边。
*   对每组边都进行必要的反转来保证一致性。
*   确定网格内部方向；如有需要，对面片进行翻转。
*   找出折叠边界。
*   生成多边形网格 Mesh（网）。

Mesh 中所有的点都只存储一次；通过点之间的拓扑关系来决定图形。

#### 条化

Stripification.

将三角形网格转化为多边形条带。

##### Triangle Strips

三角形条带…OpenGL 已经提供了画条带的方法了。

## SE-302::Compilers

编译！ 編譯！编译器！

Oh my compilers...

### Basic Blocks & Traces

基本块与轨迹。還是在這一齣。

上次我們已經得到了一般的 IR（中間表示）了。但是這還是沒有標準化的樹形表示。為了翻譯出正經的機器代碼，我們需要進行正規化以得到「Canonical Form」的表示。

### Canonical Form

規範樹有下面的特點：

a. 不包含 SEQ 或 ESEQ；

b. 每一個 CALL 的父親節點不是 `EXP`（⋯），就是 `MOVE`（``TEMP` $t$，⋯）。

#### 消 ESEQ

方法是一級級地將其向上提升（即提升到外層），直到它可以被安全地轉換成 SEQ 節點。

#####等價變換

有如下的等價變換：

*   ESEQ(s1, ESEQ(s2, e)) => ESEQ(SEQ(s1, s2), e)。
*   BINOP(op, ESEQ(s, e1), e2) => ESEQ(s, BINOP(op, e1, e2))。

*   MEM(ESEQ(s, e1)) => ESEQ(s, MEM(e1))
*   JUMP(ESEQ(s, e1)) => SEQ(s, JUMP(e1))
*   CJUMP(op, ESEQ(s, e1), e2, l1, l2) => SEQ(s, CJUMP(op, e1, e2, l1, l2))

*   BINOP(op, e1, ESEQ(s, e2)) => ESEQ(MOVE(TEMP t, e1)), ESEQ(s, BINOP(op, TEMP t, e2))

>   >   留意：如果直接按照上面的 BINOP 作轉換的話，
>   >
>   >   轉換前後，求值順序有變；副作用的順序不一樣。
>
>   >   因此必須在保證原有 Statement 求值順序的前提下進行轉換。
>   >
>   >   （方法就是利用臨時寄存器來做中轉。）

*   CJUMP(op, e1, ESEQ(s, e2), l1, l2) => SEQ(MOVE(TEMP tm e1), SEQ(s, CJUMP(opm TEMP t, e2, l1, l2)))

*   BINOP(op, e1, ESEQ(s, e2)) => ESEQ(s, BINOP(op, e1, e2))
*   CJUMP(op, e1, ESEQ(s, e2), l1, l2) => SEQ(s, CJUMP(op, e1, e2, l1, l2))

##### 算法

表示為「REORDER」。重排列。抽離出其中的 ESEQ。然後返回一個處理過的 Statement。

因為樹的特性，可以遞歸地調用自己來整理自己的子樹。

類似於 JUMP 的節點在整理時，應該一併對自己的子樹進行「REORDER」。

####將 CALL 移到頂層

BINOP(PLUS, CALL(...), CALL(...))

觀察這個表達式。這裡有個問題：一般的 FUNCTION CALL 返回值是固定放置在 %rax 寄存器裡的。

如果不特別處理，第二個 FUNCTION CALL 會覆寫掉第一個 FUNCTION CALL 的返回值。

因此，需要將 CALL(...) 變形成 ESEQ(MOVE(TEMP t, CALL(f, args)), TEMP t)。

本質上就是多用一個臨時寄存器來存放函數的返回值。而已。

##### 特別

假如本身就有一個放置在 MOVE 裡的 CALL，就不需要移動了。否則會產生無限 MOVE。

#### 線性形式

在完成了上面兩項規定的條款之後，就可以對我們更新的 IR 進行線性化了。

SEQ(SEQ(a, b), c) = SEQ(A, SEQ(b, c))

反覆應用這一規則，最終目的形式是：

SEQ(s1, SEQ(s2, SEQ(s3, ......)))

SEQ 這裏失去了所有結構信息。可以直接寫作

s1, s2, s3, ...

即可。

#### 條件分支

留意到 Tree 式中間表示包含一個非常特別的指令：CJUMP。

他可以根據輸入的條件選擇跳往兩個不同的位置。

（我懷疑這是故意增加的難度）

這就引出了一個問題：控制流問題。程序執行的過程中可能會因為一些原因而走向不同的位置。

這種分支帶來的不同走向藉由「Basic Block」實現。

###Basic Blocks & Trace

#### 基本塊

本質上也就是一個語句序列；程序控制只能從這一序列的開頭進入；結尾離開。不可以中途開車。

##### 標準格式

1.  最先一條語句：一個 LABEL，標識特定語句塊的開始；
2.  ⋯⋯中間的有效代碼。其中不包含任何 LABEL、JUMP、或 CJUMP。
3.  最後一條語句：JUMP 或 CJUMP。

由於有了這一嚴格的限制條件，因此很容易就可以將整個 SEQUENCE 分割為 BLOCKS；

遇到 LABEL 開始一個 BLOCK，遇到一個 JUMP/CJUMP 則結束一個 BLOCK。

##### 尾聲

為了保證 JUMP／CJUMP 的完整性，確保最後一個 BLOCK 也能有地方 JUMP 去，

我們聲明一個名為 done 的 LABEL，包含一些 Epilogue 指令（如退棧、還原寄存器等操作）；

讓已知的最後一個 BLOCK 有地方去。

##### 緒言

有 Epilogue 就有 Prologue；也會有一個位於程序開始的第一個 BLOCK 來執行一些初始操作。

#### 軌跡

程序控制在這一系列 BLOCKS 之間跳躍的流程，稱為軌跡。

不同的 BLOCKS 之間的流動關係可以藉由「控制流圖」的形式展現。

##### 生成軌跡

觀察 Chinese Book P133 的 Algorithm 8-1 來生成軌跡。

##### 優化完善

如果某一個基本塊跟下一個基本塊連結且不包含其他流向下一基本塊的軌跡，則可以將這兩個基本塊合併。

很多時候，我們會發現某一個基本塊的下一步流向基本都會指向跟自己相鄰的下一個基本塊。

（還不是因為 CJUMP 必須提供兩個跳轉方向，導致了很多不必要的 JUMP 位置）

藉由這種方法，可以省略到很多不必要的基本塊。

#####最優化軌跡

不打算再對此進行優化，比如針對轉移次數、訪問頻率等的優化，這裡都不做了。

再見。

### Instruction Selection

又見面啦。

上面提到的 Tree 語言，仍然只是一種中間化的表示。還不是 instructions。

這裏，我們會進行「指令選擇」；Instruction Selection，根據我們上一章得到的 Canonical Tree，選出合適的指令進行填充，最終得到很類似匯編的東西。

要根據 Canonical Tree，從可用的機器指令中選出合適的那些來不重疊地覆蓋整棵樹。

Cover 完全之後，這一步就告完成。

#### Jouette 體系結構

（感覺每來一章你就要提出一個新結構⋯）

（Jouette Architecture，也是僅供教學使用，完全搭不上工業使用的邊的中號玩具）

包含下面的基本指令：

*   ADD（算術操作。無趣。）

*   MUL（算術操作。無聊。）

*   SUB（算術操作。無他。）

*   DIV（算術操作。無言。）

*   ADDI（把一個常數和一個 register value 求和之後放入目的寄存器。）

    （特別地，允許只提供一個 constant value 將其放置在目的寄存器中，當作一個賦值操作。）

*   SUBI

*   LOAD（ri <— M[rj + c]）。）

    （可以任意交換 rj 和 c；可以不提供 rj；可以不提供 rj 和 c；）

    （也可以什麼都不提供。不知道是想幹什麼。）

*   STORE（M[rj + c] <— ri）

    （和 LOAD 的表示同樣。只是樹形結構略有區別；有一個頂天的 MOVE。）

*   MOVEM

    （Memory to Memory Move）。內存到內存的移動。

為了方便，Jouette 保證這些指令都可以在單個 Cycle 內完成，除了 MOVEM。

根據 ICS 裡我們學到的知識，通過流水線可以加速 Memory 操作，使得幾乎全部操作都只佔用一個 Cycle；唯獨 MtoM 操作沒法這麼操作。

#### 覆蓋

現在，我們要拿著這九文大錢（×）來覆蓋我們的正規樹了。留意到我們總能實現一個覆蓋，因為僅僅使用覆蓋一個節點的瓦片來做覆蓋總是可行的。（只是那太囉嗦了。）

很容易發現，覆蓋的操作是不唯一的。可以輕鬆找出很多種不同的覆蓋方法。

採用哪種是我們的自由。但必須承認，覆蓋各有別。

##### 最優覆蓋、最佳覆蓋

英文原著採用的是 Optimum 和 Optimal 兩個區別很細微的詞。

Optimum（最優）覆蓋定義為所有瓦片執行代價之和最小的覆蓋方式；

Optimal（最佳）覆蓋定義為不存在兩個相鄰的瓦片可以連結成一個代價更小的瓦片的覆蓋。

（P.S. 指令的代價即為其執行時間。）

（Jouette 指令集說，除了 MOVEM 以外的其他八條指令執行時間均為一 Cycle。）

可以證明：最優覆蓋總是最佳的（這一眼就能看出）；而最佳指令則不一定是最優的。

（事實上的情況比這複雜得多；不同的執行跟組合順序可能導致流水線產生 Stall 和 Bubble；這會導致實際執行代價和理論上看起來存在一些區別。）

（好的編譯器應該能針對這些情況進行處理。）

（我寫的可不是什麼好東西。）

#### 指令選擇算法

主要是基於 Maximal Munch 的算法。